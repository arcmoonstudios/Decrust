/* src/circuit_breaker.rs */
#![warn(missing_docs)]
//! **Brief:** Circuit breaker implementation for resilience.
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
//! + [Error Handling Framework]
//!  - [Circuit Breaker Pattern]
//!  - [Fault Tolerance]
//!  - [Service Resilience]
//!  - [Adaptive Thresholds]
//!  - [Performance Monitoring]
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
// **GitHub:** [ArcMoon Studios](https://github.com/arcmoonstudios)
// **Copyright:** (c) 2025 ArcMoon Studios
// **Author:** Lord Xyn
// **License:** MIT

//! This module provides a CircuitBreaker struct that helps protect the system
//! from cascading failures when interacting with external services or performing
//! operations prone to repeated errors.

use super::backtrace::DecrustBacktrace as Backtrace;
use super::{DecrustError, Result};
use std::collections::VecDeque;
use std::fmt;
use std::sync::{Arc, Mutex, RwLock};
use std::time::{Duration, Instant, SystemTime};
use std::thread;
use std::sync::mpsc;

#[cfg(feature = "tokio")]
use tokio::time;

/// Represents the state of the circuit breaker.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum CircuitBreakerState {
    /// The circuit is closed, operations are allowed.
    Closed,
    /// The circuit is open, operations are rejected immediately.
    Open,
    /// The circuit is partially open, allowing a limited number of test operations.
    HalfOpen,
}

impl Default for CircuitBreakerState {
    fn default() -> Self {
        CircuitBreakerState::Closed
    }
}

impl fmt::Display for CircuitBreakerState {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Closed => write!(f, "Closed"),
            Self::Open => write!(f, "Open"),
            Self::HalfOpen => write!(f, "Half-Open"),
        }
    }
}

/// Type of operation outcome.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum CircuitOperationType {
    /// Operation completed successfully
    Success,
    /// Operation failed with an error
    Failure,
    /// Operation was rejected by the circuit breaker (e.g., when Open or HalfOpen limit reached)
    Rejected,
    /// Operation timed out
    Timeout,
}

impl fmt::Display for CircuitOperationType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Success => write!(f, "Success"),
            Self::Failure => write!(f, "Failure"),
            Self::Rejected => write!(f, "Rejected"),
            Self::Timeout => write!(f, "Timeout"),
        }
    }
}

/// Represents an event of state transition
#[derive(Debug, Clone)]
pub struct CircuitTransitionEvent {
    /// The state the circuit breaker is transitioning from
    pub from_state: CircuitBreakerState,
    /// The state the circuit breaker is transitioning to
    pub to_state: CircuitBreakerState,
    /// When the transition occurred
    pub timestamp: SystemTime,
    /// The reason for the state transition
    pub reason: String,
    /// Additional context about the transition
    pub context: std::collections::HashMap<String, String>,
}

impl CircuitTransitionEvent {
    /// Creates a new transition event
    pub fn new(
        from_state: CircuitBreakerState, 
        to_state: CircuitBreakerState, 
        reason: impl Into<String>
    ) -> Self {
        Self {
            from_state,
            to_state,
            timestamp: SystemTime::now(),
            reason: reason.into(),
            context: std::collections::HashMap::new(),
        }
    }

    /// Adds context to the transition event
    pub fn with_context(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.context.insert(key.into(), value.into());
        self
    }
}

/// Observer trait for circuit breaker events.
///
/// Implement this trait to react to state changes, operation results,
/// and other significant events from the circuit breaker.
pub trait CircuitBreakerObserver: Send + Sync {
    /// Called when the circuit breaker's state changes.
    fn on_state_change(&self, name: &str, event: &CircuitTransitionEvent);
    
    /// Called before an operation is attempted (if not rejected immediately).
    fn on_operation_attempt(&self, name: &str, state: CircuitBreakerState);
    
    /// Called after an operation completes or is rejected/timed out.
    fn on_operation_result(
        &self,
        name: &str,
        op_type: CircuitOperationType,
        duration: Duration,
        error: Option<&DecrustError>,
    );
    
    /// Called when the circuit breaker is manually reset.
    fn on_reset(&self, name: &str);

    /// Called when thresholds are adjusted automatically
    fn on_threshold_adjustment(&self, name: &str, old_threshold: f64, new_threshold: f64, reason: &str);

    /// Called when performance metrics are updated
    fn on_metrics_update(&self, name: &str, metrics: &CircuitMetrics);
}

/// Metrics collected by the circuit breaker
#[derive(Debug, Clone, Default)]
pub struct CircuitMetrics {
    /// Current state of the circuit breaker
    pub state: CircuitBreakerState,
    /// Total number of requests processed by the circuit breaker
    pub total_requests: u64,
    /// Number of successful requests
    pub successful_requests: u64,
    /// Number of failed requests
    pub failed_requests: u64,
    /// Number of requests rejected due to circuit breaker being open
    pub rejected_requests: u64,
    /// Number of requests that timed out
    pub timeout_requests: u64,
    /// Current count of consecutive failures
    pub consecutive_failures: u32,
    /// Current count of consecutive successes
    pub consecutive_successes: u32,
    /// Timestamp of the last error that occurred
    pub last_error_timestamp: Option<SystemTime>,
    /// Timestamp of the last state transition
    pub last_transition_timestamp: Option<SystemTime>,
    /// Current failure rate calculated over the sliding window (0.0 to 1.0)
    pub failure_rate_in_window: Option<f64>,
    /// Current rate of slow calls calculated over the sliding window (0.0 to 1.0)
    pub slow_call_rate_in_window: Option<f64>,
    /// Average response time in the current window
    pub average_response_time: Option<Duration>,
    /// 95th percentile response time
    pub p95_response_time: Option<Duration>,
    /// 99th percentile response time
    pub p99_response_time: Option<Duration>,
    /// Current health score (0.0 to 1.0, higher is better)
    pub health_score: f64,
    /// Time spent in each state
    pub time_in_states: std::collections::HashMap<CircuitBreakerState, Duration>,
}

impl CircuitMetrics {
    /// Calculate overall success rate
    pub fn success_rate(&self) -> f64 {
        if self.total_requests == 0 {
            0.0
        } else {
            self.successful_requests as f64 / self.total_requests as f64
        }
    }

    /// Calculate overall failure rate
    pub fn failure_rate(&self) -> f64 {
        if self.total_requests == 0 {
            0.0
        } else {
            self.failed_requests as f64 / self.total_requests as f64
        }
    }

    /// Check if the circuit is healthy
    pub fn is_healthy(&self) -> bool {
        self.health_score > 0.7 && self.failure_rate() < 0.1
    }

    /// Get a summary string of key metrics
    pub fn summary(&self) -> String {
        format!(
            "State: {}, Requests: {}, Success Rate: {:.1}%, Health: {:.1}%",
            self.state,
            self.total_requests,
            self.success_rate() * 100.0,
            self.health_score * 100.0
        )
    }
}

/// Configuration for the CircuitBreaker.
///
/// Defines thresholds and timeouts that control the behavior of the circuit breaker.
#[derive(Clone)]
pub struct CircuitBreakerConfig {
    /// The number of consecutive failures after which the circuit opens.
    pub failure_threshold: usize,
    /// The failure rate (0.0 to 1.0) within the sliding window that causes the circuit to open.
    pub failure_rate_threshold: f64,
    /// The minimum number of requests in the sliding window before the failure rate is considered.
    pub minimum_request_threshold_for_rate: usize,
    /// The number of consecutive successes required in HalfOpen state to transition to Closed.
    pub success_threshold_to_close: usize,
    /// The duration the circuit stays Open before transitioning to HalfOpen.
    pub reset_timeout: Duration,
    /// The maximum number of operations allowed to execute concurrently when in HalfOpen state.
    pub half_open_max_concurrent_operations: usize,
    /// Optional timeout for individual operations executed through the circuit breaker.
    pub operation_timeout: Option<Duration>,
    /// The size of the sliding window used for calculating failure rates.
    pub sliding_window_size: usize,
    /// An optional predicate to determine if a specific `DecrustError` should be considered a failure.
    /// If `None`, all `Err` results are considered failures.
    pub error_predicate: Option<Arc<dyn Fn(&DecrustError) -> bool + Send + Sync>>,
    /// The size of the history window for detailed metrics.
    pub metrics_window_size: usize,
    /// Whether to track detailed metrics.
    pub track_metrics: bool,
    /// Threshold for an operation to be considered a "slow call".
    pub slow_call_duration_threshold: Option<Duration>,
    /// Rate of slow calls (0.0 to 1.0) in the window that can cause the circuit to open.
    pub slow_call_rate_threshold: Option<f64>,
    /// Whether to enable adaptive threshold adjustment
    pub enable_adaptive_thresholds: bool,
    /// How often to adjust thresholds (if adaptive is enabled)
    pub threshold_adjustment_interval: Duration,
    /// Maximum factor by which thresholds can be adjusted
    pub max_threshold_adjustment_factor: f64,
    /// Minimum health score required to keep circuit closed
    pub min_health_score: f64,
    /// Whether to enable exponential backoff for reset timeout
    pub enable_exponential_backoff: bool,
    /// Maximum reset timeout when using exponential backoff
    pub max_reset_timeout: Duration,
    /// Factor for exponential backoff
    pub backoff_multiplier: f64,
}

impl Default for CircuitBreakerConfig {
    fn default() -> Self {
        Self {
            failure_threshold: 5,
            failure_rate_threshold: 0.5,
            minimum_request_threshold_for_rate: 10,
            success_threshold_to_close: 3,
            reset_timeout: Duration::from_secs(30),
            half_open_max_concurrent_operations: 1,
            operation_timeout: Some(Duration::from_secs(5)),
            sliding_window_size: 100,
            error_predicate: None,
            metrics_window_size: 100,
            track_metrics: true,
            slow_call_duration_threshold: Some(Duration::from_millis(1000)),
            slow_call_rate_threshold: Some(0.3),
            enable_adaptive_thresholds: false,
            threshold_adjustment_interval: Duration::from_secs(300), // 5 minutes
            max_threshold_adjustment_factor: 2.0,
            min_health_score: 0.7,
            enable_exponential_backoff: false,
            max_reset_timeout: Duration::from_secs(300), // 5 minutes
            backoff_multiplier: 2.0,
        }
    }
}

impl fmt::Debug for CircuitBreakerConfig {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("CircuitBreakerConfig")
            .field("failure_threshold", &self.failure_threshold)
            .field("failure_rate_threshold", &self.failure_rate_threshold)
            .field("minimum_request_threshold_for_rate", &self.minimum_request_threshold_for_rate)
            .field("success_threshold_to_close", &self.success_threshold_to_close)
            .field("reset_timeout", &self.reset_timeout)
            .field("half_open_max_concurrent_operations", &self.half_open_max_concurrent_operations)
            .field("operation_timeout", &self.operation_timeout)
            .field("sliding_window_size", &self.sliding_window_size)
            .field("error_predicate", &if self.error_predicate.is_some() { "Some(<function>)" } else { "None" })
            .field("metrics_window_size", &self.metrics_window_size)
            .field("track_metrics", &self.track_metrics)
            .field("slow_call_duration_threshold", &self.slow_call_duration_threshold)
            .field("slow_call_rate_threshold", &self.slow_call_rate_threshold)
            .field("enable_adaptive_thresholds", &self.enable_adaptive_thresholds)
            .field("threshold_adjustment_interval", &self.threshold_adjustment_interval)
            .field("max_threshold_adjustment_factor", &self.max_threshold_adjustment_factor)
            .field("min_health_score", &self.min_health_score)
            .field("enable_exponential_backoff", &self.enable_exponential_backoff)
            .field("max_reset_timeout", &self.max_reset_timeout)
            .field("backoff_multiplier", &self.backoff_multiplier)
            .finish()
    }
}

/// Internal state of the circuit breaker
#[derive(Debug)]
struct InnerState {
    state: CircuitBreakerState,
    opened_at: Option<Instant>,
    half_open_entered_at: Option<Instant>,
    consecutive_failures: usize,
    consecutive_successes: usize,
    half_open_concurrency_count: usize,
    results_window: VecDeque<bool>, // true for success, false for failure
    slow_call_window: VecDeque<bool>, // true if call was slow
    response_times: VecDeque<Duration>, // for calculating percentiles
    metrics: CircuitMetrics,
    failure_count_since_open: usize, // for exponential backoff
    current_reset_timeout: Duration, // for exponential backoff
    last_threshold_adjustment: Instant,
    adaptive_failure_threshold: f64,
    adaptive_rate_threshold: f64,
    state_entry_times: std::collections::HashMap<CircuitBreakerState, Instant>,
}

impl Default for InnerState {
    fn default() -> Self {
        let mut state_times = std::collections::HashMap::new();
        state_times.insert(CircuitBreakerState::Closed, Instant::now());
        
        Self {
            state: CircuitBreakerState::Closed,
            opened_at: None,
            half_open_entered_at: None,
            consecutive_failures: 0,
            consecutive_successes: 0,
            half_open_concurrency_count: 0,
            results_window: VecDeque::with_capacity(100),
            slow_call_window: VecDeque::with_capacity(100),
            response_times: VecDeque::with_capacity(100),
            metrics: CircuitMetrics::default(),
            failure_count_since_open: 0,
            current_reset_timeout: Duration::from_secs(30),
            last_threshold_adjustment: Instant::now(),
            adaptive_failure_threshold: 0.5,
            adaptive_rate_threshold: 0.5,
            state_entry_times: state_times,
        }
    }
}

impl InnerState {
    /// Calculate health score based on recent performance
    fn calculate_health_score(&self) -> f64 {
        if self.results_window.is_empty() {
            return 1.0; // No data means healthy by default
        }

        let success_count = self.results_window.iter().filter(|&&success| success).count();
        let success_rate = success_count as f64 / self.results_window.len() as f64;
        
        // Factor in slow calls
        let slow_penalty = if self.slow_call_window.is_empty() {
            0.0
        } else {
            let slow_count = self.slow_call_window.iter().filter(|&&slow| slow).count();
            let slow_rate = slow_count as f64 / self.slow_call_window.len() as f64;
            slow_rate * 0.3 // Slow calls reduce health by up to 30%
        };

        // Factor in consecutive failures
        let consecutive_penalty = (self.consecutive_failures as f64 * 0.1).min(0.5);

        (success_rate - slow_penalty - consecutive_penalty).max(0.0).min(1.0)
    }

    /// Calculate response time percentiles
    fn calculate_percentiles(&self) -> (Option<Duration>, Option<Duration>) {
        if self.response_times.is_empty() {
            return (None, None);
        }

        let mut sorted_times: Vec<Duration> = self.response_times.iter().cloned().collect();
        sorted_times.sort();

        let p95_idx = (sorted_times.len() as f64 * 0.95) as usize;
        let p99_idx = (sorted_times.len() as f64 * 0.99) as usize;

        let p95 = if p95_idx < sorted_times.len() {
            Some(sorted_times[p95_idx])
        } else {
            sorted_times.last().cloned()
        };

        let p99 = if p99_idx < sorted_times.len() {
            Some(sorted_times[p99_idx])
        } else {
            sorted_times.last().cloned()
        };

        (p95, p99)
    }

    /// Update time tracking for current state
    fn update_state_time(&mut self, now: Instant) {
        if let Some(entry_time) = self.state_entry_times.get(&self.state) {
            let time_in_state = now.duration_since(*entry_time);
            *self.metrics.time_in_states.entry(self.state).or_insert(Duration::ZERO) += time_in_state;
        }
    }
}

/// A circuit breaker implementation to prevent cascading failures.
pub struct CircuitBreaker {
    name: String,
    config: RwLock<CircuitBreakerConfig>,
    inner: RwLock<InnerState>,
    observers: Mutex<Vec<Arc<dyn CircuitBreakerObserver>>>,
    background_tasks: Mutex<Vec<thread::JoinHandle<()>>>,
}

impl CircuitBreaker {
    /// Creates a new CircuitBreaker instance
    pub fn new(name: impl Into<String>, config: CircuitBreakerConfig) -> Arc<Self> {
        let circuit = Arc::new(Self {
            name: name.into(),
            config: RwLock::new(config.clone()),
            inner: RwLock::new(InnerState::default()),
            observers: Mutex::new(Vec::new()),
            background_tasks: Mutex::new(Vec::new()),
        });

        // Start background tasks if adaptive thresholds are enabled
        if config.enable_adaptive_thresholds {
            circuit.start_adaptive_threshold_task();
        }

        circuit
    }

    /// Add an observer to the circuit breaker
    pub fn add_observer(&self, observer: Arc<dyn CircuitBreakerObserver>) {
        let mut observers = self.observers.lock().unwrap();
        observers.push(observer);
    }

    /// Remove all observers
    pub fn clear_observers(&self) {
        let mut observers = self.observers.lock().unwrap();
        observers.clear();
    }

    /// Get the current state of the circuit breaker
    pub fn state(&self) -> CircuitBreakerState {
        let inner = self.inner.read().unwrap();
        inner.state
    }

    /// Get the current metrics of the circuit breaker
    pub fn metrics(&self) -> CircuitMetrics {
        let mut inner = self.inner.write().unwrap();
        self.update_metrics_internal(&mut inner);
        inner.metrics.clone()
    }

    /// Get the name of the circuit breaker
    pub fn name(&self) -> &str {
        &self.name
    }

    /// Update the circuit breaker configuration
    pub fn update_config(&self, new_config: CircuitBreakerConfig) {
        let mut config = self.config.write().unwrap();
        *config = new_config;
        
        // Clear any cached adaptive thresholds to force recalculation
        let mut inner = self.inner.write().unwrap();
        inner.last_threshold_adjustment = Instant::now();
    }

    /// Trip the circuit breaker manually
    pub fn trip(&self) {
        let mut inner = self.inner.write().unwrap();
        let prev_state = inner.state;
        
        self.transition_to_open_internal(&mut inner, "Manual trip");
        
        let event = CircuitTransitionEvent::new(prev_state, CircuitBreakerState::Open, "Manual trip")
            .with_context("trigger", "manual");

        drop(inner);
        self.notify_state_change(&event);
    }

    /// Reset the circuit breaker to closed state
    pub fn reset(&self) {
        let mut inner = self.inner.write().unwrap();
        let prev_state = inner.state;
        
        self.reset_internal(&mut inner);
        
        let event = CircuitTransitionEvent::new(prev_state, CircuitBreakerState::Closed, "Manual reset")
            .with_context("trigger", "manual");

        drop(inner);
        self.notify_state_change(&event);
        self.notify_reset();
    }

    /// Execute an operation through the circuit breaker
    pub fn execute<F, Ret>(&self, operation: F) -> Result<Ret>
    where
        F: FnOnce() -> Result<Ret>,
    {
        let start_time = Instant::now();
        let state = self.state();

        self.notify_operation_attempt(state);

        match state {
            CircuitBreakerState::Open => {
                self.handle_open_state(operation, start_time)
            }
            CircuitBreakerState::HalfOpen => {
                self.execute_half_open(operation, start_time)
            }
            CircuitBreakerState::Closed => {
                self.execute_closed(operation, start_time)
            }
        }
    }

    /// Execute an async operation through the circuit breaker
    #[cfg(feature = "tokio")]
    pub async fn execute_async<F, Fut, Ret>(&self, operation: F) -> Result<Ret>
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = Result<Ret>>,
    {
        let start_time = Instant::now();
        let state = self.state();

        self.notify_operation_attempt(state);

        match state {
            CircuitBreakerState::Open => {
                self.handle_open_state_async(operation, start_time).await
            }
            CircuitBreakerState::HalfOpen => {
                self.execute_half_open_async(operation, start_time).await
            }
            CircuitBreakerState::Closed => {
                self.execute_closed_async(operation, start_time).await
            }
        }
    }

    /// Check if the circuit breaker is healthy
    pub fn is_healthy(&self) -> bool {
        let inner = self.inner.read().unwrap();
        inner.metrics.is_healthy()
    }

    /// Get detailed health information
    pub fn health_report(&self) -> String {
        let inner = self.inner.read().unwrap();
        format!(
            "Circuit Breaker '{}' Health Report:\n\
             State: {}\n\
             Health Score: {:.1}%\n\
             Success Rate: {:.1}%\n\
             Total Requests: {}\n\
             Consecutive Failures: {}\n\
             Window Failure Rate: {:.1}%\n\
             Slow Call Rate: {:.1}%",
            self.name,
            inner.state,
            inner.metrics.health_score * 100.0,
            inner.metrics.success_rate() * 100.0,
            inner.metrics.total_requests,
            inner.metrics.consecutive_failures,
            inner.metrics.failure_rate_in_window.unwrap_or(0.0) * 100.0,
            inner.metrics.slow_call_rate_in_window.unwrap_or(0.0) * 100.0
        )
    }

    // Private helper methods

    /// Handle operation when circuit is open
    fn handle_open_state<F, Ret>(&self, _operation: F, _start_time: Instant) -> Result<Ret>
    where
        F: FnOnce() -> Result<Ret>,
    {
        // Check if reset timeout has elapsed
        let should_transition = {
            let inner = self.inner.read().unwrap();
            if let Some(opened_at) = inner.opened_at {
                opened_at.elapsed() >= inner.current_reset_timeout
            } else {
                false
            }
        };

        if should_transition {
            let mut inner = self.inner.write().unwrap();
            self.transition_to_half_open_internal(&mut inner, "Reset timeout elapsed");
            drop(inner);
            
            // Retry the operation in half-open state
            self.execute(_operation)
        } else {
            // Still open, reject the operation
            self.record_rejected();
            let retry_after = {
                let inner = self.inner.read().unwrap();
                inner.current_reset_timeout.checked_sub(
                    inner.opened_at.unwrap().elapsed()
                ).unwrap_or_default()
            };
            
            Err(DecrustError::CircuitBreakerOpen {
                name: self.name.clone(),
                retry_after: Some(retry_after),
                failure_count: Some(self.inner.read().unwrap().consecutive_failures as u32),
                last_error: Some("Circuit breaker is open".to_string()),
                backtrace: Backtrace::generate(),
            })
        }
    }

    /// Handle async operation when circuit is open
    #[cfg(feature = "tokio")]
    async fn handle_open_state_async<F, Fut, Ret>(&self, operation: F, _start_time: Instant) -> Result<Ret>
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = Result<Ret>>,
    {
        // Check if reset timeout has elapsed
        let should_transition = {
            let inner = self.inner.read().unwrap();
            if let Some(opened_at) = inner.opened_at {
                opened_at.elapsed() >= inner.current_reset_timeout
            } else {
                false
            }
        };

        if should_transition {
            let mut inner = self.inner.write().unwrap();
            self.transition_to_half_open_internal(&mut inner, "Reset timeout elapsed");
            drop(inner);
            
            // Retry the operation in half-open state
            self.execute_async(operation).await
        } else {
            // Still open, reject the operation
            self.record_rejected();
            let retry_after = {
                let inner = self.inner.read().unwrap();
                inner.current_reset_timeout.checked_sub(
                    inner.opened_at.unwrap().elapsed()
                ).unwrap_or_default()
            };
            
            Err(DecrustError::CircuitBreakerOpen {
                name: self.name.clone(),
                retry_after: Some(retry_after),
                failure_count: Some(self.inner.read().unwrap().consecutive_failures as u32),
                last_error: Some("Circuit breaker is open".to_string()),
                backtrace: Backtrace::generate(),
            })
        }
    }

    /// Execute operation in Closed state
    fn execute_closed<F, Ret>(&self, operation: F, start_time: Instant) -> Result<Ret>
    where
        F: FnOnce() -> Result<Ret>,
    {
        let config = self.config.read().unwrap().clone();
        
        let result = if let Some(timeout) = config.operation_timeout {
            self.execute_with_timeout(operation, timeout)
        } else {
            operation()
        };

        let duration = start_time.elapsed();

        match &result {
            Ok(_) => {
                self.record_success(duration);
            }
            Err(e) => {
                if self.should_count_as_failure(e) {
                    self.record_failure(e, duration);

                    // Check if we need to open the circuit
                    if self.should_open_circuit() {
                        let mut inner = self.inner.write().unwrap();
                        self.transition_to_open_internal(&mut inner, "Failure threshold reached");
                    }
                } else {
                    // Error not counted as failure for circuit breaking
                    self.record_success(duration);
                }
            }
        }

        result
    }

    /// Execute async operation in Closed state
    #[cfg(feature = "tokio")]
    async fn execute_closed_async<F, Fut, Ret>(&self, operation: F, start_time: Instant) -> Result<Ret>
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = Result<Ret>>,
    {
        let config = self.config.read().unwrap().clone();
        
        let result = if let Some(timeout) = config.operation_timeout {
            self.execute_with_timeout_async(operation, timeout).await
        } else {
            operation().await
        };

        let duration = start_time.elapsed();

        match &result {
            Ok(_) => {
                self.record_success(duration);
            }
            Err(e) => {
                if self.should_count_as_failure(e) {
                    self.record_failure(e, duration);

                    // Check if we need to open the circuit
                    if self.should_open_circuit() {
                        let mut inner = self.inner.write().unwrap();
                        self.transition_to_open_internal(&mut inner, "Failure threshold reached");
                    }
                } else {
                    // Error not counted as failure for circuit breaking
                    self.record_success(duration);
                }
            }
        }

        result
    }

    /// Execute operation in HalfOpen state
    fn execute_half_open<F, Ret>(&self, operation: F, start_time: Instant) -> Result<Ret>
    where
        F: FnOnce() -> Result<Ret>,
    {
        // Check if we can proceed with the operation
        {
            let mut inner = self.inner.write().unwrap();
            let config = self.config.read().unwrap();
            
            if inner.half_open_concurrency_count >= config.half_open_max_concurrent_operations {
                // Too many concurrent operations in half-open state
                self.record_rejected();
                return Err(DecrustError::CircuitBreakerOpen {
                    name: self.name.clone(),
                    retry_after: Some(Duration::from_millis(100)),
                    failure_count: Some(inner.consecutive_failures as u32),
                    last_error: Some("Too many concurrent operations in half-open state".to_string()),
                    backtrace: Backtrace::generate(),
                });
            }

            // Increment concurrency count
            inner.half_open_concurrency_count += 1;
        }

        // Execute the operation
        let config = self.config.read().unwrap().clone();
        let result = if let Some(timeout) = config.operation_timeout {
            self.execute_with_timeout(operation, timeout)
        } else {
            operation()
        };

        let duration = start_time.elapsed();

        // Decrement concurrency count
        {
            let mut inner = self.inner.write().unwrap();
            inner.half_open_concurrency_count = inner.half_open_concurrency_count.saturating_sub(1);
        }

        match &result {
            Ok(_) => {
                self.record_success(duration);

                // Check if we can close the circuit
                let should_close = {
                    let inner = self.inner.read().unwrap();
                    let config = self.config.read().unwrap();
                    inner.consecutive_successes >= config.success_threshold_to_close
                };

                if should_close {
                    let mut inner = self.inner.write().unwrap();
                    self.transition_to_closed_internal(&mut inner, "Success threshold reached");
                }
            }
            Err(e) => {
                if self.should_count_as_failure(e) {
                    self.record_failure(e, duration);

                    // Any failure in half-open should open the circuit again
                    let mut inner = self.inner.write().unwrap();
                    self.transition_to_open_internal(&mut inner, "Failure in half-open state");
                } else {
                    // Error not counted as failure for circuit breaking
                    self.record_success(duration);
                }
            }
        }

        result
    }

    /// Execute async operation in HalfOpen state
    #[cfg(feature = "tokio")]
    async fn execute_half_open_async<F, Fut, Ret>(&self, operation: F, start_time: Instant) -> Result<Ret>
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = Result<Ret>>,
    {
        // Check if we can proceed with the operation
        {
            let mut inner = self.inner.write().unwrap();
            let config = self.config.read().unwrap();
            
            if inner.half_open_concurrency_count >= config.half_open_max_concurrent_operations {
                // Too many concurrent operations in half-open state
                self.record_rejected();
                return Err(DecrustError::CircuitBreakerOpen {
                    name: self.name.clone(),
                    retry_after: Some(Duration::from_millis(100)),
                    failure_count: Some(inner.consecutive_failures as u32),
                    last_error: Some("Too many concurrent operations in half-open state".to_string()),
                    backtrace: Backtrace::generate(),
                });
            }

            // Increment concurrency count
            inner.half_open_concurrency_count += 1;
        }

        // Execute the operation
        let config = self.config.read().unwrap().clone();
        let result = if let Some(timeout) = config.operation_timeout {
            self.execute_with_timeout_async(operation, timeout).await
        } else {
            operation().await
        };

        let duration = start_time.elapsed();

        // Decrement concurrency count
        {
            let mut inner = self.inner.write().unwrap();
            inner.half_open_concurrency_count = inner.half_open_concurrency_count.saturating_sub(1);
        }

        match &result {
            Ok(_) => {
                self.record_success(duration);

                // Check if we can close the circuit
                let should_close = {
                    let inner = self.inner.read().unwrap();
                    let config = self.config.read().unwrap();
                    inner.consecutive_successes >= config.success_threshold_to_close
                };

                if should_close {
                    let mut inner = self.inner.write().unwrap();
                    self.transition_to_closed_internal(&mut inner, "Success threshold reached");
                }
            }
            Err(e) => {
                if self.should_count_as_failure(e) {
                    self.record_failure(e, duration);

                    // Any failure in half-open should open the circuit again
                    let mut inner = self.inner.write().unwrap();
                    self.transition_to_open_internal(&mut inner, "Failure in half-open state");
                } else {
                    // Error not counted as failure for circuit breaking
                    self.record_success(duration);
                }
            }
        }

        result
    }

    /// Execute operation with timeout
    fn execute_with_timeout<F, Ret>(&self, operation: F, timeout: Duration) -> Result<Ret>
    where
        F: FnOnce() -> Result<Ret>,
    {
        let (tx, rx) = mpsc::channel();

        let handle = thread::spawn(move || {
            let result = operation();
            let _ = tx.send(result);
        });

        match rx.recv_timeout(timeout) {
            Ok(result) => {
                let _ = handle.join();
                result
            }
            Err(mpsc::RecvTimeoutError::Timeout) => {
                // Thread is still running, but we've timed out
                self.record_timeout();
                Err(DecrustError::Timeout {
                    operation: format!("Operation in circuit breaker '{}'", self.name),
                    duration: timeout,
                    expected_duration: Some(timeout),
                    backtrace: Backtrace::generate(),
                })
            }
            Err(mpsc::RecvTimeoutError::Disconnected) => {
                // Thread panicked
                let _ = handle.join();
                self.record_timeout();
                Err(DecrustError::Internal {
                    message: "Operation thread panicked".to_string(),
                    source: super::OptionalError::none(),
                    component: Some(format!("circuit_breaker_{}", self.name)),
                    backtrace: Backtrace::generate(),
                })
            }
        }
    }

    /// Execute async operation with timeout
    #[cfg(feature = "tokio")]
    async fn execute_with_timeout_async<F, Fut, Ret>(&self, operation: F, timeout: Duration) -> Result<Ret>
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = Result<Ret>>,
    {
        match time::timeout(timeout, operation()).await {
            Ok(result) => result,
            Err(_) => {
                self.record_timeout();
                Err(DecrustError::Timeout {
                    operation: format!("Operation in circuit breaker '{}'", self.name),
                    duration: timeout,
                    expected_duration: Some(timeout),
                    backtrace: Backtrace::generate(),
                })
            }
        }
    }

    /// Internal state transition to open
    fn transition_to_open_internal(&self, inner: &mut InnerState, reason: &str) {
        let prev_state = inner.state;
        inner.update_state_time(Instant::now());
        
        inner.state = CircuitBreakerState::Open;
        inner.opened_at = Some(Instant::now());
        inner.consecutive_successes = 0;
        inner.failure_count_since_open += 1;
        
        // Update reset timeout for exponential backoff
        let config = self.config.read().unwrap();
        if config.enable_exponential_backoff {
            inner.current_reset_timeout = (inner.current_reset_timeout.as_secs_f64() * config.backoff_multiplier)
                .min(config.max_reset_timeout.as_secs_f64());
            inner.current_reset_timeout = Duration::from_secs_f64(inner.current_reset_timeout.as_secs_f64());
        }

        // Update metrics
        inner.state_entry_times.insert(CircuitBreakerState::Open, Instant::now());
        inner.metrics.state = CircuitBreakerState::Open;
        inner.metrics.last_transition_timestamp = Some(SystemTime::now());

        let event = CircuitTransitionEvent::new(prev_state, CircuitBreakerState::Open, reason)
            .with_context("failure_count", inner.consecutive_failures.to_string())
            .with_context("reset_timeout", format!("{:?}", inner.current_reset_timeout));

        self.notify_state_change(&event);
    }

    /// Internal state transition to half-open
    fn transition_to_half_open_internal(&self, inner: &mut InnerState, reason: &str) {
        let prev_state = inner.state;
        inner.update_state_time(Instant::now());
        
        inner.state = CircuitBreakerState::HalfOpen;
        inner.half_open_entered_at = Some(Instant::now());
        inner.consecutive_successes = 0;
        inner.half_open_concurrency_count = 0;

        // Update metrics
        inner.state_entry_times.insert(CircuitBreakerState::HalfOpen, Instant::now());
        inner.metrics.state = CircuitBreakerState::HalfOpen;
        inner.metrics.last_transition_timestamp = Some(SystemTime::now());

        let event = CircuitTransitionEvent::new(prev_state, CircuitBreakerState::HalfOpen, reason);
        self.notify_state_change(&event);
    }

    /// Internal state transition to closed
    fn transition_to_closed_internal(&self, inner: &mut InnerState, reason: &str) {
        let prev_state = inner.state;
        inner.update_state_time(Instant::now());
        
        inner.state = CircuitBreakerState::Closed;
        inner.opened_at = None;
        inner.half_open_entered_at = None;
        inner.consecutive_failures = 0;
        inner.failure_count_since_open = 0;
        
        // Reset timeout to original value
        let config = self.config.read().unwrap();
        inner.current_reset_timeout = config.reset_timeout;

        // Update metrics
        inner.state_entry_times.insert(CircuitBreakerState::Closed, Instant::now());
        inner.metrics.state = CircuitBreakerState::Closed;
        inner.metrics.last_transition_timestamp = Some(SystemTime::now());

        let event = CircuitTransitionEvent::new(prev_state, CircuitBreakerState::Closed, reason);
        self.notify_state_change(&event);
    }

    /// Internal reset logic
    fn reset_internal(&self, inner: &mut InnerState) {
        inner.update_state_time(Instant::now());
        
        inner.state = CircuitBreakerState::Closed;
        inner.opened_at = None;
        inner.half_open_entered_at = None;
        inner.consecutive_failures = 0;
        inner.consecutive_successes = 0;
        inner.half_open_concurrency_count = 0;
        inner.failure_count_since_open = 0;
        
        // Reset timeout to original value
        let config = self.config.read().unwrap();
        inner.current_reset_timeout = config.reset_timeout;

        // Update metrics
        inner.state_entry_times.insert(CircuitBreakerState::Closed, Instant::now());
        inner.metrics.state = CircuitBreakerState::Closed;
        inner.metrics.consecutive_failures = 0;
        inner.metrics.consecutive_successes = 0;
        inner.metrics.last_transition_timestamp = Some(SystemTime::now());

        // Clear windows
        inner.results_window.clear();
        inner.slow_call_window.clear();
        inner.response_times.clear();
    }

    /// Record successful operation
    fn record_success(&self, duration: Duration) {
        let mut inner = self.inner.write().unwrap();
        let config = self.config.read().unwrap();
        
        inner.consecutive_successes += 1;
        inner.consecutive_failures = 0;

        // Update sliding window
        if inner.results_window.len() >= config.sliding_window_size {
            inner.results_window.pop_front();
        }
        inner.results_window.push_back(true);

        // Update response times
        if inner.response_times.len() >= config.metrics_window_size {
            inner.response_times.pop_front();
        }
        inner.response_times.push_back(duration);

        // Check if the call was slow
        let was_slow = if let Some(threshold) = config.slow_call_duration_threshold {
            duration >= threshold
        } else {
            false
        };

        // Update slow call window
        if inner.slow_call_window.len() >= config.sliding_window_size {
            inner.slow_call_window.pop_front();
        }
        inner.slow_call_window.push_back(was_slow);

        // Update metrics
        self.update_metrics_internal(&mut inner);

        drop(inner);
        drop(config);

        self.notify_operation_result(CircuitOperationType::Success, duration, None);
    }

    /// Record failed operation
    fn record_failure(&self, error: &DecrustError, duration: Duration) {
        let mut inner = self.inner.write().unwrap();
        let config = self.config.read().unwrap();
        
        inner.consecutive_failures += 1;
        inner.consecutive_successes = 0;

        // Update sliding window
        if inner.results_window.len() >= config.sliding_window_size {
            inner.results_window.pop_front();
        }
        inner.results_window.push_back(false);

        // Update response times
        if inner.response_times.len() >= config.metrics_window_size {
            inner.response_times.pop_front();
        }
        inner.response_times.push_back(duration);

        // Check if the call was slow (although it failed)
        let was_slow = if let Some(threshold) = config.slow_call_duration_threshold {
            duration >= threshold
        } else {
            false
        };

        // Update slow call window
        if inner.slow_call_window.len() >= config.sliding_window_size {
            inner.slow_call_window.pop_front();
        }
        inner.slow_call_window.push_back(was_slow);

        // Update metrics
        self.update_metrics_internal(&mut inner);

        let error_clone = error.clone();
        drop(inner);
        drop(config);

        self.notify_operation_result(CircuitOperationType::Failure, duration, Some(&error_clone));
    }

    /// Record rejected operation
    fn record_rejected(&self) {
        let mut inner = self.inner.write().unwrap();
        self.update_metrics_internal(&mut inner);
        drop(inner);

        // Zero duration since operation was rejected
        self.notify_operation_result(CircuitOperationType::Rejected, Duration::from_secs(0), None);
    }

    /// Record timed out operation
    fn record_timeout(&self) {
        let mut inner = self.inner.write().unwrap();
        let config = self.config.read().unwrap();
        
        inner.consecutive_failures += 1;
        inner.consecutive_successes = 0;

        // Update sliding window
        if inner.results_window.len() >= config.sliding_window_size {
            inner.results_window.pop_front();
        }
        inner.results_window.push_back(false);

        // Update metrics
        self.update_metrics_internal(&mut inner);

        let timeout_duration = config.operation_timeout.unwrap_or_default();
        drop(inner);
        drop(config);

        let timeout_error = DecrustError::Timeout {
            operation: format!("Operation in circuit breaker '{}'", self.name),
            duration: timeout_duration,
            expected_duration: Some(timeout_duration),
            backtrace: Backtrace::generate(),
        };

        self.notify_operation_result(
            CircuitOperationType::Timeout,
            timeout_duration,
            Some(&timeout_error),
        );
    }

    /// Update internal metrics
    fn update_metrics_internal(&self, inner: &mut InnerState) {
        inner.metrics.total_requests += 1;
        inner.metrics.consecutive_failures = inner.consecutive_failures as u32;
        inner.metrics.consecutive_successes = inner.consecutive_successes as u32;
        inner.metrics.last_error_timestamp = Some(SystemTime::now());

        // Calculate rates
        if inner.results_window.is_empty() {
            inner.metrics.failure_rate_in_window = None;
        } else {
            let failure_count = inner.results_window.iter().filter(|&&success| !success).count();
            let failure_rate = failure_count as f64 / inner.results_window.len() as f64;
            inner.metrics.failure_rate_in_window = Some(failure_rate);
        }

        if inner.slow_call_window.is_empty() {
            inner.metrics.slow_call_rate_in_window = None;
        } else {
            let slow_count = inner.slow_call_window.iter().filter(|&&slow| slow).count();
            let slow_rate = slow_count as f64 / inner.slow_call_window.len() as f64;
            inner.metrics.slow_call_rate_in_window = Some(slow_rate);
        }

        // Calculate average response time
        if !inner.response_times.is_empty() {
            let total_time: Duration = inner.response_times.iter().sum();
            inner.metrics.average_response_time = Some(total_time / inner.response_times.len() as u32);
        }

        // Calculate percentiles
        let (p95, p99) = inner.calculate_percentiles();
        inner.metrics.p95_response_time = p95;
        inner.metrics.p99_response_time = p99;

        // Update health score
        inner.metrics.health_score = inner.calculate_health_score();

        // Update state times
        inner.update_state_time(Instant::now());
    }

    /// Check if the circuit should open
    fn should_open_circuit(&self) -> bool {
        let inner = self.inner.read().unwrap();
        let config = self.config.read().unwrap();

        // Open if consecutive failures exceed threshold
        if inner.consecutive_failures >= config.failure_threshold {
            return true;
        }

        // Check failure rate if we have enough samples
        if inner.results_window.len() >= config.minimum_request_threshold_for_rate {
            let failure_count = inner.results_window.iter().filter(|&&success| !success).count();
            let failure_rate = failure_count as f64 / inner.results_window.len() as f64;

            if failure_rate >= inner.adaptive_rate_threshold {
                return true;
            }
        }

        // Check slow call rate if configured
        if let (Some(threshold), true) = (
            config.slow_call_rate_threshold,
            !inner.slow_call_window.is_empty(),
        ) {
            let slow_count = inner.slow_call_window.iter().filter(|&&slow| slow).count();
            let slow_rate = slow_count as f64 / inner.slow_call_window.len() as f64;

            if slow_rate >= threshold {
                return true;
            }
        }

        // Check health score
        if inner.metrics.health_score < config.min_health_score {
            return true;
        }

        false
    }

    /// Check if an error should count as a failure
    fn should_count_as_failure(&self, error: &DecrustError) -> bool {
        let config = self.config.read().unwrap();
        
        // If there's a custom predicate, use that
        if let Some(predicate) = &config.error_predicate {
            return (predicate.as_ref())(error);
        }

        // By default, all errors count as failures except for certain types
        match error {
            DecrustError::CircuitBreakerOpen { .. } => false, // Don't count circuit breaker errors
            _ => true,
        }
    }

    /// Start adaptive threshold adjustment task
    fn start_adaptive_threshold_task(self: &Arc<Self>) {
        let circuit = Arc::clone(self);
        let handle = thread::spawn(move || {
            loop {
                thread::sleep(Duration::from_secs(60)); // Check every minute
                
                let config = circuit.config.read().unwrap();
                if !config.enable_adaptive_thresholds {
                    break;
                }
                
                let should_adjust = {
                    let inner = circuit.inner.read().unwrap();
                    inner.last_threshold_adjustment.elapsed() >= config.threshold_adjustment_interval
                };
                
                if should_adjust {
                    circuit.adjust_adaptive_thresholds();
                }
                
                drop(config);
            }
        });
        
        let mut tasks = self.background_tasks.lock().unwrap();
        tasks.push(handle);
    }

    /// Adjust thresholds based on recent performance
    fn adjust_adaptive_thresholds(&self) {
        let mut inner = self.inner.write().unwrap();
        let config = self.config.read().unwrap();
        
        let current_health = inner.metrics.health_score;
        let target_health = config.min_health_score;
        
        // Adjust failure rate threshold based on health
        let old_rate_threshold = inner.adaptive_rate_threshold;
        if current_health < target_health {
            // Health is poor, make thresholds more sensitive
            inner.adaptive_rate_threshold = (inner.adaptive_rate_threshold * 0.9)
                .max(0.1); // Don't go below 10%
        } else if current_health > target_health + 0.1 {
            // Health is good, relax thresholds slightly
            inner.adaptive_rate_threshold = (inner.adaptive_rate_threshold * 1.05)
                .min(config.failure_rate_threshold * config.max_threshold_adjustment_factor);
        }

        // Adjust failure count threshold similarly
        let old_failure_threshold = inner.adaptive_failure_threshold;
        if current_health < target_health {
            inner.adaptive_failure_threshold = (inner.adaptive_failure_threshold * 0.9)
                .max(3.0); // Don't go below 3 failures
        } else if current_health > target_health + 0.1 {
            inner.adaptive_failure_threshold = (inner.adaptive_failure_threshold * 1.05)
                .min(config.failure_threshold as f64 * config.max_threshold_adjustment_factor);
        }

        inner.last_threshold_adjustment = Instant::now();

        // Notify observers of threshold changes
        if (old_rate_threshold - inner.adaptive_rate_threshold).abs() > 0.01 {
            self.notify_threshold_adjustment(
                old_rate_threshold,
                inner.adaptive_rate_threshold,
                "rate_threshold_adaptive_adjustment",
            );
        }

        if (old_failure_threshold - inner.adaptive_failure_threshold).abs() > 0.1 {
            self.notify_threshold_adjustment(
                old_failure_threshold,
                inner.adaptive_failure_threshold,
                "failure_threshold_adaptive_adjustment",
            );
        }
    }

    /// Observer notification methods
    fn notify_state_change(&self, event: &CircuitTransitionEvent) {
        let observers = self.observers.lock().unwrap();
        for observer in &*observers {
            observer.on_state_change(&self.name, event);
        }
    }

    fn notify_operation_attempt(&self, state: CircuitBreakerState) {
        let observers = self.observers.lock().unwrap();
        for observer in &*observers {
            observer.on_operation_attempt(&self.name, state);
        }
    }

    fn notify_operation_result(
        &self,
        op_type: CircuitOperationType,
        duration: Duration,
        error: Option<&DecrustError>,
    ) {
        let observers = self.observers.lock().unwrap();
        for observer in &*observers {
            observer.on_operation_result(&self.name, op_type, duration, error);
        }
    }

    fn notify_reset(&self) {
        let observers = self.observers.lock().unwrap();
        for observer in &*observers {
            observer.on_reset(&self.name);
        }
    }

    fn notify_threshold_adjustment(&self, old_threshold: f64, new_threshold: f64, reason: &str) {
        let observers = self.observers.lock().unwrap();
        for observer in &*observers {
            observer.on_threshold_adjustment(&self.name, old_threshold, new_threshold, reason);
        }
    }

    fn notify_metrics_update(&self, metrics: &CircuitMetrics) {
        let observers = self.observers.lock().unwrap();
        for observer in &*observers {
            observer.on_metrics_update(&self.name, metrics);
        }
    }
}

impl Drop for CircuitBreaker {
    fn drop(&mut self) {
        // Wait for background tasks to complete
        let mut tasks = self.background_tasks.lock().unwrap();
        for handle in tasks.drain(..) {
            let _ = handle.join();
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use super::super::OptionalError;
    use std::sync::atomic::{AtomicUsize, Ordering};
    use std::sync::Arc;

    // Mock observer for testing
    struct TestObserver {
        state_changes: AtomicUsize,
        operation_attempts: AtomicUsize,
        operation_results: AtomicUsize,
        resets: AtomicUsize,
        threshold_adjustments: AtomicUsize,
        metrics_updates: AtomicUsize,
    }

    impl TestObserver {
        fn new() -> Self {
            Self {
                state_changes: AtomicUsize::new(0),
                operation_attempts: AtomicUsize::new(0),
                operation_results: AtomicUsize::new(0),
                resets: AtomicUsize::new(0),
                threshold_adjustments: AtomicUsize::new(0),
                metrics_updates: AtomicUsize::new(0),
            }
        }
    }

    impl CircuitBreakerObserver for TestObserver {
        fn on_state_change(&self, _name: &str, _event: &CircuitTransitionEvent) {
            self.state_changes.fetch_add(1, Ordering::SeqCst);
        }

        fn on_operation_attempt(&self, _name: &str, _state: CircuitBreakerState) {
            self.operation_attempts.fetch_add(1, Ordering::SeqCst);
        }

        fn on_operation_result(
            &self,
            _name: &str,
            _op_type: CircuitOperationType,
            _duration: Duration,
            _error: Option<&DecrustError>,
        ) {
            self.operation_results.fetch_add(1, Ordering::SeqCst);
        }

        fn on_reset(&self, _name: &str) {
            self.resets.fetch_add(1, Ordering::SeqCst);
        }

        fn on_threshold_adjustment(&self, _name: &str, _old: f64, _new: f64, _reason: &str) {
            self.threshold_adjustments.fetch_add(1, Ordering::SeqCst);
        }

        fn on_metrics_update(&self, _name: &str, _metrics: &CircuitMetrics) {
            self.metrics_updates.fetch_add(1, Ordering::SeqCst);
        }
    }

    #[test]
    fn test_circuit_breaker_initial_state() {
        let config = CircuitBreakerConfig::default();
        let cb = CircuitBreaker::new("test-circuit", config);

        assert_eq!(cb.state(), CircuitBreakerState::Closed);
        assert!(cb.is_healthy());
    }

    #[test]
    fn test_circuit_breaker_trip() {
        let config = CircuitBreakerConfig::default();
        let cb = CircuitBreaker::new("test-circuit", config);

        // Initial state should be Closed
        assert_eq!(cb.state(), CircuitBreakerState::Closed);

        // Trip the circuit
        cb.trip();

        // State should now be Open
        assert_eq!(cb.state(), CircuitBreakerState::Open);

        // Reset the circuit
        cb.reset();

        // State should be Closed again
        assert_eq!(cb.state(), CircuitBreakerState::Closed);
    }

    #[test]
    fn test_circuit_breaker_observer_notifications() {
        let config = CircuitBreakerConfig::default();
        let cb = CircuitBreaker::new("test-circuit", config);
        let observer = Arc::new(TestObserver::new());

        // Add observer
        cb.add_observer(observer.clone());

        // Trip the circuit
        cb.trip();

        // Reset the circuit
        cb.reset();

        // Verify observer counts
        assert_eq!(observer.state_changes.load(Ordering::SeqCst), 2); // One for trip, one for reset
        assert_eq!(observer.resets.load(Ordering::SeqCst), 1);
    }

    #[test]
    fn test_circuit_breaker_execute_success() {
        let config = CircuitBreakerConfig::default();
        let cb = CircuitBreaker::new("test-circuit", config);

        // Execute successful operation
        let result: Result<i32, DecrustError> = cb.execute(|| Ok(42));

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 42);
    }

    #[test]
    fn test_circuit_breaker_execute_error() {
        let config = CircuitBreakerConfig::default();
        let cb = CircuitBreaker::new("test-circuit", config);

        // Execute operation that returns an error
        let result: Result<i32, DecrustError> = cb.execute(|| {
            Err(DecrustError::Internal {
                message: "Test error".to_string(),
                source: OptionalError::new(None),
                component: Some("test".to_string()),
                backtrace: Backtrace::generate(),
            })
        });

        assert!(result.is_err());
    }

    #[test]
    fn test_circuit_breaker_failure_threshold() {
        let mut config = CircuitBreakerConfig::default();
        config.failure_threshold = 3;
        
        let cb = CircuitBreaker::new("test-circuit", config);

        // Execute failing operations
        for _ in 0..3 {
            let _result: Result<(), DecrustError> = cb.execute(|| {
                Err(DecrustError::Internal {
                    message: "Test failure".to_string(),
                    source: OptionalError::new(None),
                    component: Some("test".to_string()),
                    backtrace: Backtrace::generate(),
                })
            });
        }

        // Circuit should now be open
        assert_eq!(cb.state(), CircuitBreakerState::Open);
    }

    #[test]
    fn test_circuit_breaker_metrics() {
        let config = CircuitBreakerConfig::default();
        let cb = CircuitBreaker::new("test-circuit", config);

        // Execute some operations
        let _success: Result<(), DecrustError> = cb.execute(|| Ok(()));
        let _failure: Result<(), DecrustError> = cb.execute(|| {
            Err(DecrustError::Internal {
                message: "Test failure".to_string(),
                source: OptionalError::new(None),
                component: Some("test".to_string()),
                backtrace: Backtrace::generate(),
            })
        });

        let metrics = cb.metrics();
        assert_eq!(metrics.total_requests, 2);
        assert_eq!(metrics.successful_requests, 1);
        assert_eq!(metrics.failed_requests, 1);
        assert_eq!(metrics.success_rate(), 0.5);
    }

    #[test]
    fn test_circuit_breaker_health_report() {
        let config = CircuitBreakerConfig::default();
        let cb = CircuitBreaker::new("test-circuit", config);

        let health_report = cb.health_report();
        assert!(health_report.contains("test-circuit"));
        assert!(health_report.contains("Health Score"));
        assert!(health_report.contains("Success Rate"));
    }

    #[test]
    fn test_circuit_breaker_timeout() {
        let mut config = CircuitBreakerConfig::default();
        config.operation_timeout = Some(Duration::from_millis(100));
        
        let cb = CircuitBreaker::new("test-circuit", config);

        // Execute operation that takes longer than timeout
        let result: Result<(), DecrustError> = cb.execute(|| {
            thread::sleep(Duration::from_millis(200));
            Ok(())
        });

        assert!(result.is_err());
        match result.unwrap_err() {
            DecrustError::Timeout { .. } => {}, // Expected
            other => panic!("Expected timeout error, got: {:?}", other),
        }
    }

    #[test]
    fn test_circuit_metrics_summary() {
        let mut metrics = CircuitMetrics::default();
        metrics.total_requests = 100;
        metrics.successful_requests = 85;
        metrics.failed_requests = 15;
        metrics.health_score = 0.8;

        let summary = metrics.summary();
        assert!(summary.contains("85.0%"));
        assert!(summary.contains("80.0%"));
        assert!(summary.contains("100"));
    }

    #[test]
    fn test_circuit_breaker_config_update() {
        let config = CircuitBreakerConfig::default();
        let cb = CircuitBreaker::new("test-circuit", config);

        let mut new_config = CircuitBreakerConfig::default();
        new_config.failure_threshold = 10;

        cb.update_config(new_config);

        // Config should be updated (we can't directly test this without internal access,
        // but we can verify the circuit breaker still works)
        let result: Result<(), DecrustError> = cb.execute(|| Ok(()));
        assert!(result.is_ok());
    }

    #[test]
    fn test_transition_event_context() {
        let event = CircuitTransitionEvent::new(
            CircuitBreakerState::Closed,
            CircuitBreakerState::Open,
            "Test transition"
        )
        .with_context("key", "value")
        .with_context("count", "5");

        assert_eq!(event.from_state, CircuitBreakerState::Closed);
        assert_eq!(event.to_state, CircuitBreakerState::Open);
        assert_eq!(event.reason, "Test transition");
        assert_eq!(event.context.get("key"), Some(&"value".to_string()));
        assert_eq!(event.context.get("count"), Some(&"5".to_string()));
    }
}