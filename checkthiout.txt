/* src/lib.rs */
#![warn(missing_docs)]
#![allow(stable_features)]
//! **Brief:** Main DecrustError enum with extensions and exports.
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
//! + [Error Handling Framework]  
//!  - [Unified Error Type]
//!  - [Rich Error Context]
//!  - [Circuit Breaker Pattern]
//!  - [Error Reporting]
//!  - [Autocorrection Framework]
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
// **GitHub:** [ArcMoon Studios](https://github.com/arcmoonstudios)
// **Copyright:** (c) 2025 ArcMoon Studios
// **Author:** Lord Xyn
// **License:** MIT

pub mod backtrace;
pub mod circuit_breaker;
pub mod decrust;
pub mod reporter;
pub mod syntax;
pub mod types;

use std::path::PathBuf;
use std::time::Duration;
use std::collections::HashMap;

pub use self::backtrace::{
    DecrustBacktrace as Backtrace,
    GenerateImplicitData,
    BacktraceCompat,
    BacktraceProvider,
    AsBacktrace,
    Timestamp,
    ThreadId,
    Location,
    BacktraceStatus,
    BacktraceFrame,
    location,
    implicit_data,
};

pub use self::circuit_breaker::{
    CircuitBreaker, 
    CircuitBreakerConfig, 
    CircuitBreakerObserver, 
    CircuitBreakerState,
    CircuitOperationType,
    CircuitTransitionEvent,
    CircuitMetrics,
};

pub use self::decrust::{
    AstMissingImportFixGenerator, 
    AstUnusedCodeFixGenerator, 
    AutocorrectableError,
    ClosureCaptureLifetimeFixGenerator, 
    ConfigMissingKeyFixGenerator, 
    ConfigSyntaxFixGenerator,
    Decrust, 
    DivisionByZeroFixGenerator, 
    InvalidArgumentCountFixGenerator,
    IoMissingDirectoryFixGenerator, 
    IoPermissionFixGenerator, 
    JsonParseFixGenerator,
    MissingOkErrFixGenerator, 
    NetworkConnectionFixGenerator, 
    NetworkTlsFixGenerator,
    QuestionMarkPropagationFixGenerator, 
    RecursiveTypeFixGenerator,
    ReturnLocalReferenceFixGenerator, 
    RuntimePanicFixGenerator, 
    UnnecessaryCloneFixGenerator,
    UnnecessaryParenthesesFixGenerator, 
    UnsafeUnwrapFixGenerator, 
    UnstableFeatureFixGenerator,
    UnusedMutFixGenerator, 
    YamlParseFixGenerator,
};

pub use self::reporter::{
    ErrorReportConfig, 
    ErrorReporter
};

pub use self::syntax::{
    FixTemplate as SyntaxFixTemplate, 
    SyntaxGenerator, 
    TemplateRegistry
};

pub use self::types::{
    Autocorrection, 
    ErrorCategory, 
    ErrorContext, 
    ErrorReportFormat, 
    ErrorSeverity, 
    ErrorSource,
    ExtractedParameters, 
    FixDetails, 
    FixType, 
    ParameterExtractor, 
    ParameterSource,
    DiagnosticResult,
    ErrorLocation,
    MacroExpansion,
    FixTemplate as TypesFixTemplate,
    FixGenerator,
};

/// A Result type specialized for DecrustError
pub type Result<T, E = DecrustError> = std::result::Result<T, E>;

/// A Result type specialized for diagnostic operations that can return multiple errors
pub type DiagnosticResult<T> = std::result::Result<T, Vec<DecrustError>>;

/// Wrapper for `Option<Box<dyn Error>>` to make it compatible with backtrace
///
/// This struct provides a way to handle optional error sources in a way that's
/// compatible with the backtrace error handling framework. It wraps an optional boxed
/// error trait object and provides methods to work with it.
#[derive(Debug)]
pub struct OptionalError(pub Option<Box<dyn std::error::Error + Send + Sync + 'static>>);

impl Clone for OptionalError {
    fn clone(&self) -> Self {
        match &self.0 {
            Some(err) => {
                // Create a new error with the string representation of the original error
                let cloned_err = std::io::Error::new(std::io::ErrorKind::Other, format!("{}", err));
                OptionalError(Some(Box::new(cloned_err)))
            }
            None => OptionalError(None),
        }
    }
}

impl std::fmt::Display for OptionalError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.0 {
            Some(err) => write!(f, "{}", err),
            None => write!(f, "No error"),
        }
    }
}

impl std::error::Error for OptionalError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.0 {
            Some(err) => Some(err.as_ref()),
            None => None,
        }
    }
}

impl OptionalError {
    /// Creates a new OptionalError from an optional boxed error
    ///
    /// # Parameters
    /// * `opt` - An optional boxed error trait object
    pub fn new(opt: Option<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        OptionalError(opt)
    }

    /// Checks if this OptionalError contains an actual error
    ///
    /// # Returns
    /// `true` if there is an error, `false` otherwise
    pub fn has_error(&self) -> bool {
        self.0.is_some()
    }

    /// Extracts the inner error if present
    ///
    /// # Returns
    /// The inner error if present, None otherwise
    pub fn into_inner(self) -> Option<Box<dyn std::error::Error + Send + Sync + 'static>> {
        self.0
    }

    /// Gets a reference to the inner error if present
    ///
    /// # Returns
    /// Reference to the inner error if present, None otherwise
    pub fn as_ref(&self) -> Option<&(dyn std::error::Error + Send + Sync + 'static)> {
        self.0.as_ref().map(|e| e.as_ref())
    }

    /// Maps the inner error using a function
    ///
    /// # Parameters
    /// * `f` - Function to apply to the inner error
    ///
    /// # Returns
    /// New OptionalError with the mapped error
    pub fn map<F>(self, f: F) -> Self
    where
        F: FnOnce(Box<dyn std::error::Error + Send + Sync + 'static>) -> Box<dyn std::error::Error + Send + Sync + 'static>,
    {
        OptionalError(self.0.map(f))
    }

    /// Creates an OptionalError from any error type
    ///
    /// # Parameters
    /// * `error` - The error to wrap
    ///
    /// # Returns
    /// OptionalError containing the wrapped error
    pub fn from_error<E>(error: E) -> Self
    where
        E: std::error::Error + Send + Sync + 'static,
    {
        OptionalError(Some(Box::new(error)))
    }

    /// Creates an empty OptionalError
    ///
    /// # Returns
    /// OptionalError with no inner error
    pub fn none() -> Self {
        OptionalError(None)
    }
}

impl From<Option<Box<dyn std::error::Error + Send + Sync + 'static>>> for OptionalError {
    fn from(opt: Option<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        OptionalError(opt)
    }
}

impl From<Box<dyn std::error::Error + Send + Sync + 'static>> for OptionalError {
    fn from(err: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        OptionalError(Some(err))
    }
}

impl<E> From<E> for OptionalError
where
    E: std::error::Error + Send + Sync + 'static,
{
    fn from(err: E) -> Self {
        OptionalError(Some(Box::new(err)))
    }
}

impl AsRef<Option<Box<dyn std::error::Error + Send + Sync + 'static>>> for OptionalError {
    fn as_ref(&self) -> &Option<Box<dyn std::error::Error + Send + Sync + 'static>> {
        &self.0
    }
}

/// Unified error type for Decrust.
#[derive(Debug)]
pub enum DecrustError {
    /// I/O related errors
    Io {
        /// The underlying I/O error
        source: std::io::Error,
        /// Optional path to the file or resource that caused the error
        path: Option<PathBuf>,
        /// Description of the operation that failed
        operation: String,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Parsing errors (JSON, YAML, etc.)
    Parse {
        /// The underlying parsing error
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        /// The type of data being parsed (e.g., "JSON", "YAML")
        kind: String,
        /// Additional context information about the parsing operation
        context_info: String,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Network related errors
    Network {
        /// The underlying network error
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        /// Optional URL that was being accessed
        url: Option<String>,
        /// The type of network operation (e.g., "HTTP", "TCP")
        kind: String,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Configuration related errors
    Config {
        /// Error message describing the configuration issue
        message: String,
        /// Optional path to the configuration file
        path: Option<PathBuf>,
        /// Optional underlying error that caused the configuration issue
        source: OptionalError,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Validation errors
    Validation {
        /// Name of the field that failed validation
        field: String,
        /// Description of the validation error
        message: String,
        /// Expected value or format
        expected: Option<String>,
        /// Actual value that failed validation
        actual: Option<String>,
        /// Validation rule that was violated
        rule: Option<String>,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Internal errors
    Internal {
        /// Description of the internal error
        message: String,
        /// Optional underlying error
        source: OptionalError,
        /// Component or module where the error occurred
        component: Option<String>,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Circuit breaker is open
    CircuitBreakerOpen {
        /// Name of the circuit breaker
        name: String,
        /// Optional duration after which the circuit breaker might transition to half-open
        retry_after: Option<Duration>,
        /// Current failure count
        failure_count: Option<u32>,
        /// Last error that caused the circuit to open
        last_error: Option<String>,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Operation timed out
    Timeout {
        /// Name of the operation that timed out
        operation: String,
        /// Duration after which the operation timed out
        duration: Duration,
        /// Expected duration for the operation
        expected_duration: Option<Duration>,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Resource exhaustion
    ResourceExhausted {
        /// Name of the resource that was exhausted
        resource: String,
        /// The limit of the resource
        limit: String,
        /// The current value that exceeded the limit
        current: String,
        /// Suggested remediation
        suggestion: Option<String>,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Resource not found
    NotFound {
        /// Type of resource that was not found (e.g., "User", "File")
        resource_type: String,
        /// Identifier of the resource that was not found
        identifier: String,
        /// Additional search criteria that were used
        search_criteria: Option<HashMap<String, String>>,
        /// Suggested alternatives or similar resources
        suggestions: Vec<String>,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// State conflict
    StateConflict {
        /// Description of the state conflict
        message: String,
        /// Current state
        current_state: Option<String>,
        /// Expected state
        expected_state: Option<String>,
        /// Possible causes of the conflict
        possible_causes: Vec<String>,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Concurrency related errors
    Concurrency {
        /// Description of the concurrency error
        message: String,
        /// Optional underlying error
        source: OptionalError,
        /// Type of concurrency issue (deadlock, race condition, etc.)
        issue_type: Option<String>,
        /// Resources involved in the concurrency issue
        resources: Vec<String>,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// External service errors
    ExternalService {
        /// Name of the external service that caused the error
        service_name: String,
        /// Description of the error from the external service
        message: String,
        /// Optional underlying error from the external service
        source: OptionalError,
        /// HTTP status code if applicable
        status_code: Option<u16>,
        /// Request ID for tracking
        request_id: Option<String>,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Missing value errors
    MissingValue {
        /// Description of the missing value or item
        item_description: String,
        /// Context where the value was expected
        context: Option<String>,
        /// Possible sources where the value could be found
        possible_sources: Vec<String>,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Multiple errors
    MultipleErrors {
        /// Collection of errors that occurred
        errors: Vec<DecrustError>,
        /// Description of how the errors are related
        relationship: Option<String>,
        /// Whether all errors must be resolved or just some
        resolution_strategy: Option<String>,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Error with rich context
    WithRichContext {
        /// Rich context information attached to the error
        context: types::ErrorContext,
        /// The original error that is being wrapped with context
        source: Box<DecrustError>,
    },

    /// Style and formatting errors
    Style {
        /// The style error message
        message: String,
        /// File path where the style issue was found
        file_path: Option<PathBuf>,
        /// Line number of the style issue
        line_number: Option<u32>,
        /// Column number of the style issue
        column_number: Option<u32>,
        /// Suggested fix for the style issue
        suggested_fix: Option<String>,
        /// Style rule that was violated
        rule_name: Option<String>,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// General purpose error wrapper
    Oops {
        /// Custom error message
        message: String,
        /// The underlying error being wrapped
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        /// Additional context information
        context: HashMap<String, String>,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },
}

impl Clone for DecrustError {
    fn clone(&self) -> Self {
        match self {
            Self::Io {
                source,
                path,
                operation,
                ..
            } => Self::Io {
                source: std::io::Error::new(source.kind(), format!("{}", source)),
                path: path.clone(),
                operation: operation.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::Parse {
                source,
                kind,
                context_info,
                ..
            } => Self::Parse {
                source: Box::new(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!("{}", source),
                )),
                kind: kind.clone(),
                context_info: context_info.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::Network {
                source, url, kind, ..
            } => Self::Network {
                source: Box::new(std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!("{}", source),
                )),
                url: url.clone(),
                kind: kind.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::Config {
                message,
                path,
                source,
                ..
            } => Self::Config {
                message: message.clone(),
                path: path.clone(),
                source: source.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::Validation { 
                field, 
                message, 
                expected,
                actual,
                rule,
                .. 
            } => Self::Validation {
                field: field.clone(),
                message: message.clone(),
                expected: expected.clone(),
                actual: actual.clone(),
                rule: rule.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::Internal {
                message, 
                source, 
                component,
                ..
            } => Self::Internal {
                message: message.clone(),
                source: source.clone(),
                component: component.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::CircuitBreakerOpen {
                name, 
                retry_after, 
                failure_count,
                last_error,
                ..
            } => Self::CircuitBreakerOpen {
                name: name.clone(),
                retry_after: *retry_after,
                failure_count: *failure_count,
                last_error: last_error.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::Timeout {
                operation,
                duration,
                expected_duration,
                ..
            } => Self::Timeout {
                operation: operation.clone(),
                duration: *duration,
                expected_duration: *expected_duration,
                backtrace: Backtrace::generate(),
            },
            Self::ResourceExhausted {
                resource,
                limit,
                current,
                suggestion,
                ..
            } => Self::ResourceExhausted {
                resource: resource.clone(),
                limit: limit.clone(),
                current: current.clone(),
                suggestion: suggestion.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::NotFound {
                resource_type,
                identifier,
                search_criteria,
                suggestions,
                ..
            } => Self::NotFound {
                resource_type: resource_type.clone(),
                identifier: identifier.clone(),
                search_criteria: search_criteria.clone(),
                suggestions: suggestions.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::StateConflict { 
                message, 
                current_state,
                expected_state,
                possible_causes,
                .. 
            } => Self::StateConflict {
                message: message.clone(),
                current_state: current_state.clone(),
                expected_state: expected_state.clone(),
                possible_causes: possible_causes.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::Concurrency {
                message, 
                source, 
                issue_type,
                resources,
                ..
            } => Self::Concurrency {
                message: message.clone(),
                source: source.clone(),
                issue_type: issue_type.clone(),
                resources: resources.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::ExternalService {
                service_name,
                message,
                source,
                status_code,
                request_id,
                ..
            } => Self::ExternalService {
                service_name: service_name.clone(),
                message: message.clone(),
                source: source.clone(),
                status_code: *status_code,
                request_id: request_id.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::MissingValue {
                item_description, 
                context,
                possible_sources,
                ..
            } => Self::MissingValue {
                item_description: item_description.clone(),
                context: context.clone(),
                possible_sources: possible_sources.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::MultipleErrors { 
                errors, 
                relationship,
                resolution_strategy,
                .. 
            } => Self::MultipleErrors {
                errors: errors.clone(),
                relationship: relationship.clone(),
                resolution_strategy: resolution_strategy.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::WithRichContext { context, source } => {
                Self::WithRichContext {
                    context: context.clone(),
                    source: Box::new((**source).clone()),
                }
            }
            Self::Style { 
                message, 
                file_path,
                line_number,
                column_number,
                suggested_fix,
                rule_name,
                .. 
            } => Self::Style {
                message: message.clone(),
                file_path: file_path.clone(),
                line_number: *line_number,
                column_number: *column_number,
                suggested_fix: suggested_fix.clone(),
                rule_name: rule_name.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::Oops {
                message, 
                source, 
                context,
                ..
            } => Self::Oops {
                message: message.clone(),
                source: Box::new(std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!("{}", source),
                )),
                context: context.clone(),
                backtrace: Backtrace::generate(),
            },
        }
    }
}

impl std::fmt::Display for DecrustError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DecrustError::Io {
                source,
                path,
                operation,
                ..
            } => {
                write!(
                    f,
                    "I/O error during operation '{}' on path '{}': {}",
                    operation,
                    path.as_ref()
                        .map(|p| p.to_string_lossy().to_string())
                        .unwrap_or_else(|| "N/A".to_string()),
                    source
                )
            }
            DecrustError::Parse {
                source,
                kind,
                context_info,
                ..
            } => {
                write!(f, "{} parsing error: {} (context: {})", kind, source, context_info)
            }
            DecrustError::Network {
                source, url, kind, ..
            } => {
                write!(
                    f,
                    "{} network error: {} (URL: {})",
                    kind,
                    source,
                    url.as_deref().unwrap_or("N/A")
                )
            }
            DecrustError::Config {
                message,
                path,
                source,
                ..
            } => {
                if let Some(p) = path {
                    if let Some(s) = &source.0 {
                        write!(
                            f,
                            "Configuration error in '{}': {} ({})",
                            p.display(),
                            message,
                            s
                        )
                    } else {
                        write!(f, "Configuration error in '{}': {}", p.display(), message)
                    }
                } else if let Some(s) = &source.0 {
                    write!(f, "Configuration error: {} ({})", message, s)
                } else {
                    write!(f, "Configuration error: {}", message)
                }
            }
            DecrustError::Validation { 
                field, 
                message, 
                expected,
                actual,
                rule,
                .. 
            } => {
                write!(f, "Validation error for '{}': {}", field, message)?;
                if let Some(exp) = expected {
                    write!(f, " (expected: {})", exp)?;
                }
                if let Some(act) = actual {
                    write!(f, " (actual: {})", act)?;
                }
                if let Some(r) = rule {
                    write!(f, " (rule: {})", r)?;
                }
                Ok(())
            }
            DecrustError::Internal {
                message, 
                source, 
                component,
                ..
            } => {
                let comp_str = component.as_deref().unwrap_or("unknown");
                if let Some(s) = &source.0 {
                    write!(f, "Internal error in {}: {} ({})", comp_str, message, s)
                } else {
                    write!(f, "Internal error in {}: {}", comp_str, message)
                }
            }
            DecrustError::CircuitBreakerOpen {
                name, 
                retry_after, 
                failure_count,
                last_error,
                ..
            } => {
                write!(f, "Circuit breaker '{}' is open", name)?;
                if let Some(count) = failure_count {
                    write!(f, " (failures: {})", count)?;
                }
                if let Some(duration) = retry_after {
                    write!(f, " (retry after: {:?})", duration)?;
                }
                if let Some(err) = last_error {
                    write!(f, " (last error: {})", err)?;
                }
                Ok(())
            }
            DecrustError::Timeout {
                operation,
                duration,
                expected_duration,
                ..
            } => {
                write!(
                    f,
                    "Operation '{}' timed out after {:?}",
                    operation, duration
                )?;
                if let Some(expected) = expected_duration {
                    write!(f, " (expected: {:?})", expected)?;
                }
                Ok(())
            }
            DecrustError::ResourceExhausted {
                resource,
                limit,
                current,
                suggestion,
                ..
            } => {
                write!(
                    f,
                    "Resource '{}' exhausted: {} (limit: {})",
                    resource, current, limit
                )?;
                if let Some(sugg) = suggestion {
                    write!(f, " (suggestion: {})", sugg)?;
                }
                Ok(())
            }
            DecrustError::NotFound {
                resource_type,
                identifier,
                search_criteria,
                suggestions,
                ..
            } => {
                write!(f, "{} not found: {}", resource_type, identifier)?;
                if let Some(criteria) = search_criteria {
                    if !criteria.is_empty() {
                        write!(f, " (searched with: {:?})", criteria)?;
                    }
                }
                if !suggestions.is_empty() {
                    write!(f, " (suggestions: {:?})", suggestions)?;
                }
                Ok(())
            }
            DecrustError::StateConflict { 
                message, 
                current_state,
                expected_state,
                possible_causes,
                .. 
            } => {
                write!(f, "State conflict: {}", message)?;
                if let Some(current) = current_state {
                    write!(f, " (current: {})", current)?;
                }
                if let Some(expected) = expected_state {
                    write!(f, " (expected: {})", expected)?;
                }
                if !possible_causes.is_empty() {
                    write!(f, " (possible causes: {:?})", possible_causes)?;
                }
                Ok(())
            }
            DecrustError::Concurrency {
                message, 
                source, 
                issue_type,
                resources,
                ..
            } => {
                let issue_str = issue_type.as_deref().unwrap_or("unknown");
                write!(f, "Concurrency error ({}): {}", issue_str, message)?;
                if !resources.is_empty() {
                    write!(f, " (resources: {:?})", resources)?;
                }
                if let Some(s) = &source.0 {
                    write!(f, " ({})", s)?;
                }
                Ok(())
            }
            DecrustError::ExternalService {
                service_name,
                message,
                source,
                status_code,
                request_id,
                ..
            } => {
                write!(f, "External service '{}' error: {}", service_name, message)?;
                if let Some(code) = status_code {
                    write!(f, " (status: {})", code)?;
                }
                if let Some(id) = request_id {
                    write!(f, " (request: {})", id)?;
                }
                if let Some(s) = &source.0 {
                    write!(f, " ({})", s)?;
                }
                Ok(())
            }
            DecrustError::MissingValue {
                item_description, 
                context,
                possible_sources,
                ..
            } => {
                write!(f, "Missing value: {}", item_description)?;
                if let Some(ctx) = context {
                    write!(f, " (context: {})", ctx)?;
                }
                if !possible_sources.is_empty() {
                    write!(f, " (check: {:?})", possible_sources)?;
                }
                Ok(())
            }
            DecrustError::MultipleErrors { 
                errors, 
                relationship,
                resolution_strategy,
                .. 
            } => {
                write!(f, "Multiple errors ({} total)", errors.len())?;
                if let Some(rel) = relationship {
                    write!(f, " (relationship: {})", rel)?;
                }
                if let Some(strategy) = resolution_strategy {
                    write!(f, " (resolution: {})", strategy)?;
                }
                for (i, err) in errors.iter().enumerate() {
                    write!(f, "\n  {}. {}", i + 1, err)?;
                }
                Ok(())
            }
            DecrustError::WithRichContext {
                context, source, ..
            } => {
                write!(f, "{}: {}", context.message, source)
            }
            DecrustError::Style { 
                message, 
                file_path,
                line_number,
                column_number,
                suggested_fix,
                rule_name,
                .. 
            } => {
                write!(f, "Style issue: {}", message)?;
                if let Some(rule) = rule_name {
                    write!(f, " (rule: {})", rule)?;
                }
                if let Some(path) = file_path {
                    write!(f, " at {}", path.display())?;
                    if let Some(line) = line_number {
                        write!(f, ":{}", line)?;
                        if let Some(col) = column_number {
                            write!(f, ":{}", col)?;
                        }
                    }
                }
                if let Some(fix) = suggested_fix {
                    write!(f, " (suggestion: {})", fix)?;
                }
                Ok(())
            }
            DecrustError::Oops {
                message, 
                source, 
                context,
                ..
            } => {
                write!(f, "{}: {}", message, source)?;
                if !context.is_empty() {
                    write!(f, " (context: {:?})", context)?;
                }
                Ok(())
            }
        }
    }
}

// Implement std::error::Error for DecrustError
impl std::error::Error for DecrustError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            DecrustError::Io { source, .. } => Some(source),
            DecrustError::WithRichContext { source, .. } => Some(source.as_ref()),
            DecrustError::Oops { source, .. } => Some(source.as_ref()),
            DecrustError::Parse { source, .. } => Some(source.as_ref()),
            DecrustError::Network { source, .. } => Some(source.as_ref()),
            DecrustError::Config { source, .. } => source
                .0
                .as_ref()
                .map(|e| e.as_ref() as &(dyn std::error::Error + 'static)),
            DecrustError::Internal { source, .. } => source
                .0
                .as_ref()
                .map(|e| e.as_ref() as &(dyn std::error::Error + 'static)),
            DecrustError::Concurrency { source, .. } => source
                .0
                .as_ref()
                .map(|e| e.as_ref() as &(dyn std::error::Error + 'static)),
            DecrustError::ExternalService { source, .. } => source
                .0
                .as_ref()
                .map(|e| e.as_ref() as &(dyn std::error::Error + 'static)),
            DecrustError::MultipleErrors { errors, .. } => errors
                .first()
                .map(|e| e as &(dyn std::error::Error + 'static)),
            DecrustError::CircuitBreakerOpen { .. } => None,
            DecrustError::ResourceExhausted { .. } => None,
            DecrustError::StateConflict { .. } => None,
            DecrustError::MissingValue { .. } => None,
            DecrustError::Validation { .. } => None,
            DecrustError::NotFound { .. } => None,
            DecrustError::Timeout { .. } => None,
            DecrustError::Style { .. } => None,
        }
    }
}

// Implement PartialEq for DecrustError to support testing
impl PartialEq for DecrustError {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (DecrustError::Parse { kind: k1, .. }, DecrustError::Parse { kind: k2, .. }) => {
                k1 == k2
            }
            (DecrustError::Oops { message: m1, .. }, DecrustError::Oops { message: m2, .. }) => {
                m1 == m2
            }
            (DecrustError::Network { kind: k1, .. }, DecrustError::Network { kind: k2, .. }) => {
                k1 == k2
            }
            (DecrustError::Style { message: m1, rule_name: r1, .. }, DecrustError::Style { message: m2, rule_name: r2, .. }) => {
                m1 == m2 && r1 == r2
            }
            (
                DecrustError::Config { message: m1, .. },
                DecrustError::Config { message: m2, .. },
            ) => m1 == m2,
            (DecrustError::Io { operation: op1, .. }, DecrustError::Io { operation: op2, .. }) => {
                op1 == op2
            }
            (
                DecrustError::Internal { message: m1, component: c1, .. },
                DecrustError::Internal { message: m2, component: c2, .. },
            ) => m1 == m2 && c1 == c2,
            (
                DecrustError::Concurrency { message: m1, issue_type: t1, .. },
                DecrustError::Concurrency { message: m2, issue_type: t2, .. },
            ) => m1 == m2 && t1 == t2,
            (
                DecrustError::Timeout { operation: op1, .. },
                DecrustError::Timeout { operation: op2, .. },
            ) => op1 == op2,
            (
                DecrustError::StateConflict { message: m1, .. },
                DecrustError::StateConflict { message: m2, .. },
            ) => m1 == m2,
            (
                DecrustError::CircuitBreakerOpen { name: n1, .. },
                DecrustError::CircuitBreakerOpen { name: n2, .. },
            ) => n1 == n2,
            (
                DecrustError::ResourceExhausted { resource: r1, .. },
                DecrustError::ResourceExhausted { resource: r2, .. },
            ) => r1 == r2,
            (
                DecrustError::ExternalService {
                    service_name: s1, ..
                },
                DecrustError::ExternalService {
                    service_name: s2, ..
                },
            ) => s1 == s2,
            (
                DecrustError::MissingValue {
                    item_description: i1,
                    ..
                },
                DecrustError::MissingValue {
                    item_description: i2,
                    ..
                },
            ) => i1 == i2,
            (
                DecrustError::MultipleErrors { errors: e1, .. },
                DecrustError::MultipleErrors { errors: e2, .. },
            ) => e1 == e2,
            (
                DecrustError::Validation {
                    field: f1,
                    message: m1,
                    ..
                },
                DecrustError::Validation {
                    field: f2,
                    message: m2,
                    ..
                },
            ) => f1 == f2 && m1 == m2,
            (
                DecrustError::NotFound {
                    resource_type: r1,
                    identifier: i1,
                    ..
                },
                DecrustError::NotFound {
                    resource_type: r2,
                    identifier: i2,
                    ..
                },
            ) => r1 == r2 && i1 == i2,
            (
                DecrustError::WithRichContext {
                    context: c1,
                    source: s1,
                },
                DecrustError::WithRichContext {
                    context: c2,
                    source: s2,
                },
            ) => c1.message == c2.message && s1 == s2,
            _ => false,
        }
    }
}

impl backtrace::BacktraceCompat for DecrustError {
    fn backtrace(&self) -> Option<&backtrace::DecrustBacktrace> {
        match self {
            DecrustError::Io { backtrace, .. } => Some(backtrace),
            DecrustError::Oops { backtrace, .. } => Some(backtrace),
            DecrustError::Style { backtrace, .. } => Some(backtrace),
            DecrustError::Parse { backtrace, .. } => Some(backtrace),
            DecrustError::Config { backtrace, .. } => Some(backtrace),
            DecrustError::Timeout { backtrace, .. } => Some(backtrace),
            DecrustError::Network { backtrace, .. } => Some(backtrace),
            DecrustError::NotFound { backtrace, .. } => Some(backtrace),
            DecrustError::Internal { backtrace, .. } => Some(backtrace),
            DecrustError::Validation { backtrace, .. } => Some(backtrace),
            DecrustError::Concurrency { backtrace, .. } => Some(backtrace),
            DecrustError::MissingValue { backtrace, .. } => Some(backtrace),
            DecrustError::StateConflict { backtrace, .. } => Some(backtrace),
            DecrustError::MultipleErrors { backtrace, .. } => Some(backtrace),
            DecrustError::ExternalService { backtrace, .. } => Some(backtrace),
            DecrustError::ResourceExhausted { backtrace, .. } => Some(backtrace),
            DecrustError::CircuitBreakerOpen { backtrace, .. } => Some(backtrace),
            DecrustError::WithRichContext { source, .. } => source.backtrace(),
        }
    }
}

impl DecrustError {
    /// Adds rich context to an error
    ///
    /// This wraps the error in a WithRichContext variant, which allows for additional
    /// information to be attached to the error.
    ///
    /// # Parameters
    /// * `context` - The error context to add
    ///
    /// # Returns
    /// A new error with the context attached
    pub fn add_context(self, context: types::ErrorContext) -> Self {
        DecrustError::WithRichContext {
            context,
            source: Box::new(self),
        }
    }

    /// Adds a simple message context to an error
    ///
    /// This is a convenience method that creates a simple ErrorContext with just a message
    /// and adds it to the error.
    ///
    /// # Parameters
    /// * `message` - The message to add as context
    ///
    /// # Returns
    /// A new error with the context attached
    pub fn add_context_msg(self, message: impl Into<String>) -> Self {
        let error_context = types::ErrorContext::new(message);
        self.add_context(error_context)
    }

    /// Gets the category of this error
    ///
    /// # Returns
    /// The ErrorCategory that best describes this error
    pub fn category(&self) -> types::ErrorCategory {
        match self {
            DecrustError::Io { .. } => types::ErrorCategory::Io,
            DecrustError::Parse { .. } => types::ErrorCategory::Parsing,
            DecrustError::Network { .. } => types::ErrorCategory::Network,
            DecrustError::Config { .. } => types::ErrorCategory::Configuration,
            DecrustError::Validation { .. } => types::ErrorCategory::Validation,
            DecrustError::Internal { .. } => types::ErrorCategory::Internal,
            DecrustError::CircuitBreakerOpen { .. } => types::ErrorCategory::CircuitBreaker,
            DecrustError::Timeout { .. } => types::ErrorCategory::Timeout,
            DecrustError::ResourceExhausted { .. } => types::ErrorCategory::ResourceExhaustion,
            DecrustError::NotFound { .. } => types::ErrorCategory::NotFound,
            DecrustError::StateConflict { .. } => types::ErrorCategory::StateConflict,
            DecrustError::Concurrency { .. } => types::ErrorCategory::Concurrency,
            DecrustError::ExternalService { .. } => types::ErrorCategory::ExternalService,
            DecrustError::MultipleErrors { .. } => types::ErrorCategory::Multiple,
            DecrustError::WithRichContext { source, .. } => source.category(),
            DecrustError::Style { .. } => types::ErrorCategory::Style,
            DecrustError::Oops { .. } => types::ErrorCategory::Unspecified,
            DecrustError::MissingValue { .. } => types::ErrorCategory::Validation,
        }
    }

    /// Gets the severity of this error
    ///
    /// # Returns
    /// The ErrorSeverity level of this error
    pub fn severity(&self) -> types::ErrorSeverity {
        if let DecrustError::WithRichContext { context, .. } = self {
            context.severity
        } else {
            match self {
                DecrustError::Internal { .. } => types::ErrorSeverity::Critical,
                DecrustError::CircuitBreakerOpen { .. } => types::ErrorSeverity::Critical,
                DecrustError::ResourceExhausted { .. } => types::ErrorSeverity::Critical,
                DecrustError::MultipleErrors { .. } => types::ErrorSeverity::Error,
                DecrustError::Timeout { .. } => types::ErrorSeverity::Error,
                DecrustError::StateConflict { .. } => types::ErrorSeverity::Error,
                DecrustError::Concurrency { .. } => types::ErrorSeverity::Error,
                DecrustError::ExternalService { .. } => types::ErrorSeverity::Error,
                DecrustError::Io { .. } => types::ErrorSeverity::Error,
                DecrustError::Parse { .. } => types::ErrorSeverity::Error,
                DecrustError::Network { .. } => types::ErrorSeverity::Error,
                DecrustError::Config { .. } => types::ErrorSeverity::Warning,
                DecrustError::Validation { .. } => types::ErrorSeverity::Warning,
                DecrustError::NotFound { .. } => types::ErrorSeverity::Warning,
                DecrustError::MissingValue { .. } => types::ErrorSeverity::Warning,
                DecrustError::Style { .. } => types::ErrorSeverity::Info,
                DecrustError::Oops { .. } => types::ErrorSeverity::Error,
            }
        }
    }

    /// Gets the rich context attached to this error, if any
    ///
    /// # Returns
    /// Some(context) if this is a WithRichContext error, None otherwise
    pub fn get_rich_context(&self) -> Option<&types::ErrorContext> {
        match self {
            DecrustError::WithRichContext { context, .. } => Some(context),
            _ => None,
        }
    }

    /// Checks if this error is recoverable
    ///
    /// # Returns
    /// true if the error represents a recoverable condition
    pub fn is_recoverable(&self) -> bool {
        match self {
            DecrustError::Timeout { .. } => true,
            DecrustError::Network { .. } => true,
            DecrustError::ExternalService { .. } => true,
            DecrustError::CircuitBreakerOpen { .. } => true,
            DecrustError::ResourceExhausted { .. } => true,
            DecrustError::StateConflict { .. } => true,
            DecrustError::NotFound { .. } => false,
            DecrustError::Validation { .. } => false,
            DecrustError::Config { .. } => false,
            DecrustError::Parse { .. } => false,
            DecrustError::Style { .. } => true,
            DecrustError::WithRichContext { source, .. } => source.is_recoverable(),
            _ => false,
        }
    }

    /// Gets suggestions for resolving this error
    ///
    /// # Returns
    /// Vector of suggested resolution steps
    pub fn get_resolution_suggestions(&self) -> Vec<String> {
        match self {
            DecrustError::NotFound { suggestions, .. } => suggestions.clone(),
            DecrustError::StateConflict { possible_causes, .. } => {
                possible_causes.iter().map(|cause| format!("Check: {}", cause)).collect()
            }
            DecrustError::MissingValue { possible_sources, .. } => {
                possible_sources.iter().map(|source| format!("Look in: {}", source)).collect()
            }
            DecrustError::Style { suggested_fix: Some(fix), .. } => {
                vec![fix.clone()]
            }
            DecrustError::ResourceExhausted { suggestion: Some(sugg), .. } => {
                vec![sugg.clone()]
            }
            DecrustError::CircuitBreakerOpen { retry_after: Some(duration), .. } => {
                vec![format!("Retry after {:?}", duration)]
            }
            DecrustError::Validation { rule: Some(rule), .. } => {
                vec![format!("Follow rule: {}", rule)]
            }
            DecrustError::WithRichContext { context, source } => {
                let mut suggestions = source.get_resolution_suggestions();
                if let Some(recovery) = &context.recovery_suggestion {
                    suggestions.insert(0, recovery.clone());
                }
                suggestions
            }
            _ => Vec::new(),
        }
    }

    /// Gets additional metadata associated with this error
    ///
    /// # Returns
    /// HashMap of metadata key-value pairs
    pub fn get_metadata(&self) -> HashMap<String, String> {
        let mut metadata = HashMap::new();
        
        match self {
            DecrustError::NotFound { search_criteria: Some(criteria), .. } => {
                metadata.extend(criteria.iter().map(|(k, v)| (k.clone(), v.clone())));
            }
            DecrustError::Oops { context, .. } => {
                metadata.extend(context.iter().map(|(k, v)| (k.clone(), v.clone())));
            }
            DecrustError::WithRichContext { context, .. } => {
                metadata.extend(context.metadata.iter().map(|(k, v)| (k.clone(), v.clone())));
            }
            _ => {}
        }
        
        // Add common metadata
        metadata.insert("category".to_string(), format!("{:?}", self.category()));
        metadata.insert("severity".to_string(), format!("{:?}", self.severity()));
        metadata.insert("recoverable".to_string(), self.is_recoverable().to_string());
        
        metadata
    }
}

/// Extension trait for Result types to add context to errors
///
/// This trait provides methods to add context to errors in a Result,
/// making it easier to provide additional information about the error.
pub trait DecrustResultExt<T, EOrig> {
    /// Adds a simple message context to an error in a Result
    ///
    /// # Parameters
    /// * `message` - The message to add as context
    ///
    /// # Returns
    /// A new Result with the error wrapped in a WithRichContext variant if it was an error
    fn decrust_context_msg(self, message: impl Into<String>) -> Result<T, DecrustError>;

    /// Adds rich context to an error in a Result
    ///
    /// # Parameters
    /// * `context` - The error context to add
    ///
    /// # Returns
    /// A new Result with the error wrapped in a WithRichContext variant if it was an error
    fn decrust_context_rich(self, context: types::ErrorContext) -> Result<T, DecrustError>;

    /// Adds context with additional metadata
    ///
    /// # Parameters
    /// * `message` - The message to add as context
    /// * `metadata` - Additional metadata to include
    ///
    /// # Returns
    /// A new Result with the error wrapped with enhanced context
    fn decrust_context_with_metadata(
        self, 
        message: impl Into<String>,
        metadata: HashMap<String, String>
    ) -> Result<T, DecrustError>;
}

impl<T, E> DecrustResultExt<T, E> for std::result::Result<T, E>
where
    E: Into<DecrustError>,
{
    #[track_caller]
    fn decrust_context_msg(self, message: impl Into<String>) -> Result<T, DecrustError> {
        match self {
            Ok(value) => Ok(value),
            Err(err) => {
                let decrust_err: DecrustError = err.into();
                Err(DecrustError::WithRichContext {
                    context: types::ErrorContext::new(message),
                    source: Box::new(decrust_err),
                })
            }
        }
    }

    #[track_caller]
    fn decrust_context_rich(self, context: types::ErrorContext) -> Result<T, DecrustError> {
        match self {
            Ok(value) => Ok(value),
            Err(err) => {
                let decrust_err: DecrustError = err.into();
                Err(DecrustError::WithRichContext {
                    context,
                    source: Box::new(decrust_err),
                })
            }
        }
    }

    #[track_caller]
    fn decrust_context_with_metadata(
        self, 
        message: impl Into<String>,
        metadata: HashMap<String, String>
    ) -> Result<T, DecrustError> {
        match self {
            Ok(value) => Ok(value),
            Err(err) => {
                let decrust_err: DecrustError = err.into();
                let mut context = types::ErrorContext::new(message);
                context.metadata.extend(metadata);
                Err(DecrustError::WithRichContext {
                    context,
                    source: Box::new(decrust_err),
                })
            }
        }
    }
}

/// Extension trait for Option types to convert to Result with DecrustError
///
/// This trait provides methods to convert an Option to a Result, with a MissingValue
/// error if the Option is None.
pub trait DecrustOptionExt<T> {
    /// Converts an Option to a Result, with a MissingValue error if None
    ///
    /// # Parameters
    /// * `item_description` - Description of the missing value for the error message
    ///
    /// # Returns
    /// Ok(value) if the Option is Some(value), Err(DecrustError::MissingValue) otherwise
    fn decrust_ok_or_missing_value(
        self,
        item_description: impl Into<String>,
    ) -> Result<T, DecrustError>;

    /// Converts an Option to a Result with additional context
    ///
    /// # Parameters
    /// * `item_description` - Description of the missing value
    /// * `context` - Additional context about where the value was expected
    /// * `possible_sources` - Possible sources where the value could be found
    ///
    /// # Returns
    /// Ok(value) if the Option is Some(value), Err(DecrustError::MissingValue) otherwise
    fn decrust_ok_or_missing_with_context(
        self,
        item_description: impl Into<String>,
        context: Option<String>,
        possible_sources: Vec<String>,
    ) -> Result<T, DecrustError>;
}

impl<T> DecrustOptionExt<T> for Option<T> {
    #[track_caller]
    fn decrust_ok_or_missing_value(
        self,
        item_description: impl Into<String>,
    ) -> Result<T, DecrustError> {
        match self {
            Some(v) => Ok(v),
            None => Err(DecrustError::MissingValue {
                item_description: item_description.into(),
                context: None,
                possible_sources: Vec::new(),
                backtrace: Backtrace::generate(),
            }),
        }
    }

    #[track_caller]
    fn decrust_ok_or_missing_with_context(
        self,
        item_description: impl Into<String>,
        context: Option<String>,
        possible_sources: Vec<String>,
    ) -> Result<T, DecrustError> {
        match self {
            Some(v) => Ok(v),
            None => Err(DecrustError::MissingValue {
                item_description: item_description.into(),
                context,
                possible_sources,
                backtrace: Backtrace::generate(),
            }),
        }
    }
}

// Conversion implementations for common error types
impl From<std::io::Error> for DecrustError {
    fn from(err: std::io::Error) -> Self {
        DecrustError::Io {
            source: err,
            path: None,
            operation: "unknown".to_string(),
            backtrace: Backtrace::generate(),
        }
    }
}

impl From<serde_json::Error> for DecrustError {
    fn from(err: serde_json::Error) -> Self {
        DecrustError::Parse {
            source: Box::new(err),
            kind: "JSON".to_string(),
            context_info: "JSON parsing failed".to_string(),
            backtrace: Backtrace::generate(),
        }
    }
}

#[cfg(feature = "yaml")]
impl From<serde_yaml::Error> for DecrustError {
    fn from(err: serde_yaml::Error) -> Self {
        DecrustError::Parse {
            source: Box::new(err),
            kind: "YAML".to_string(),
            context_info: "YAML parsing failed".to_string(),
            backtrace: Backtrace::generate(),
        }
    }
}

#[cfg(feature = "toml")]
impl From<toml::de::Error> for DecrustError {
    fn from(err: toml::de::Error) -> Self {
        DecrustError::Parse {
            source: Box::new(err),
            kind: "TOML".to_string(),
            context_info: "TOML parsing failed".to_string(),
            backtrace: Backtrace::generate(),
        }
    }
}

#[cfg(feature = "reqwest")]
impl From<reqwest::Error> for DecrustError {
    fn from(err: reqwest::Error) -> Self {
        DecrustError::Network {
            source: Box::new(err),
            url: None,
            kind: "HTTP".to_string(),
            backtrace: Backtrace::generate(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use backtrace::BacktraceCompat;
    use std::collections::HashMap;

    #[test]
    fn test_error_creation_and_context() {
        let source_opt: Option<Box<dyn std::error::Error + Send + Sync + 'static>> = None;
        let err = DecrustError::Internal {
            message: "Test error".to_string(),
            source: OptionalError(source_opt),
            component: Some("test_component".to_string()),
            backtrace: Backtrace::generate(),
        };

        assert_eq!(err.category(), types::ErrorCategory::Internal);
        assert_eq!(err.severity(), types::ErrorSeverity::Critical);

        let err_with_context_res: Result<(), DecrustError> =
            Err(err).decrust_context_msg("Additional context");
        assert!(err_with_context_res.is_err());
        let err_with_context = err_with_context_res.unwrap_err();

        if let DecrustError::WithRichContext {
            context, source, ..
        } = &err_with_context
        {
            assert_eq!(context.message, "Additional context");
            if let DecrustError::Internal { message, component, .. } = source.as_ref() {
                assert_eq!(message, "Test error");
                assert_eq!(component, &Some("test_component".to_string()));
            } else {
                panic!("Expected Internal error variant, got {:?}", source);
            }
        } else {
            panic!(
                "Expected WithRichContext error variant, got {:?}",
                err_with_context
            );
        }
    }

    #[test]
    fn test_error_clone() {
        let io_err_orig = std::io::Error::new(std::io::ErrorKind::NotFound, "File not found");
        let original_err = DecrustError::Io {
            source: io_err_orig,
            path: Some(PathBuf::from("/path/to/file")),
            operation: "read_file".to_string(),
            backtrace: Backtrace::generate(),
        };

        let cloned_err = original_err.clone();

        assert_eq!(cloned_err.category(), types::ErrorCategory::Io);

        if let DecrustError::Io {
            ref path,
            ref operation,
            ref source,
            ..
        } = cloned_err
        {
            assert_eq!(*path, Some(PathBuf::from("/path/to/file")));
            assert_eq!(*operation, "read_file");
            assert_eq!(source.kind(), std::io::ErrorKind::NotFound);
        } else {
            panic!("Expected Io error variant");
        }
        assert!(BacktraceCompat::backtrace(&cloned_err).is_some());
    }

    #[test]
    fn test_option_ext() {
        let opt_value: Option<i32> = Some(42);
        let result = opt_value.decrust_ok_or_missing_value("test value");
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 42);

        let opt_none: Option<i32> = None;
        let result = opt_none.decrust_ok_or_missing_value("test value");
        assert!(result.is_err());

        if let Err(DecrustError::MissingValue {
            item_description, ..
        }) = result
        {
            assert_eq!(item_description, "test value");
        } else {
            panic!("Expected MissingValue error variant");
        }
    }

    #[test]
    fn test_option_ext_with_context() {
        let opt_none: Option<i32> = None;
        let result = opt_none.decrust_ok_or_missing_with_context(
            "test value",
            Some("test context".to_string()),
            vec!["source1".to_string(), "source2".to_string()],
        );
        assert!(result.is_err());

        if let Err(DecrustError::MissingValue {
            item_description,
            context,
            possible_sources,
            ..
        }) = result
        {
            assert_eq!(item_description, "test value");
            assert_eq!(context, Some("test context".to_string()));
            assert_eq!(possible_sources.len(), 2);
        } else {
            panic!("Expected MissingValue error variant");
        }
    }

    #[test]
    fn test_multiple_errors() {
        let err1 = DecrustError::Validation {
            field: "username".to_string(),
            message: "Username too short".to_string(),
            expected: Some("at least 3 characters".to_string()),
            actual: Some("ab".to_string()),
            rule: Some("min_length".to_string()),
            backtrace: Backtrace::generate(),
        };

        let err2 = DecrustError::Validation {
            field: "password".to_string(),
            message: "Password too weak".to_string(),
            expected: Some("strong password".to_string()),
            actual: Some("123".to_string()),
            rule: Some("password_strength".to_string()),
            backtrace: Backtrace::generate(),
        };

        let multi_err = DecrustError::MultipleErrors {
            errors: vec![err1, err2.clone()],
            relationship: Some("validation_group".to_string()),
            resolution_strategy: Some("fix_all".to_string()),
            backtrace: Backtrace::generate(),
        };

        if let DecrustError::MultipleErrors { errors, .. } = multi_err {
            assert_eq!(errors.len(), 2);
            if let DecrustError::Validation { field, .. } = &errors[0] {
                assert_eq!(field, "username");
            } else {
                panic!("Expected Validation error variant for errors[0]");
            }
            if let DecrustError::Validation { field, .. } = &errors[1] {
                assert_eq!(field, "password");
            } else {
                panic!("Expected Validation error variant for errors[1]");
            }
        } else {
            panic!("Expected MultipleErrors error variant");
        }
    }

    #[test]
    fn test_oops_error() {
        let original_io_error = std::io::Error::new(std::io::ErrorKind::Other, "some io problem");
        let mut context = HashMap::new();
        context.insert("operation".to_string(), "file_read".to_string());
        context.insert("attempt".to_string(), "3".to_string());

        let err = DecrustError::Oops {
            message: "A oops message".to_string(),
            source: Box::new(original_io_error)
                as Box<dyn std::error::Error + Send + Sync + 'static>,
            context,
            backtrace: Backtrace::generate(),
        };

        if let DecrustError::Oops {
            message, source, context, ..
        } = err
        {
            assert_eq!(message, "A oops message");
            assert_eq!(source.to_string(), "some io problem");
            assert_eq!(context.get("operation"), Some(&"file_read".to_string()));
            assert_eq!(context.get("attempt"), Some(&"3".to_string()));
        } else {
            panic!("Expected Oops error variant");
        }
    }

    #[test]
    fn test_error_metadata() {
        let err = DecrustError::NotFound {
            resource_type: "User".to_string(),
            identifier: "123".to_string(),
            search_criteria: Some({
                let mut criteria = HashMap::new();
                criteria.insert("email".to_string(), "test@example.com".to_string());
                criteria
            }),
            suggestions: vec!["Check user ID".to_string()],
            backtrace: Backtrace::generate(),
        };

        let metadata = err.get_metadata();
        assert!(metadata.contains_key("category"));
        assert!(metadata.contains_key("severity"));
        assert!(metadata.contains_key("recoverable"));
        assert_eq!(metadata.get("email"), Some(&"test@example.com".to_string()));
    }

    #[test]
    fn test_error_suggestions() {
        let err = DecrustError::ResourceExhausted {
            resource: "memory".to_string(),
            limit: "1GB".to_string(),
            current: "1.2GB".to_string(),
            suggestion: Some("Increase memory limit or optimize usage".to_string()),
            backtrace: Backtrace::generate(),
        };

        let suggestions = err.get_resolution_suggestions();
        assert_eq!(suggestions.len(), 1);
        assert_eq!(suggestions[0], "Increase memory limit or optimize usage");
    }

    #[test]
    fn test_io_error_display() {
        let path_buf = PathBuf::from("/my/file.txt");
        let io_err = std::io::Error::new(std::io::ErrorKind::NotFound, "original os error");
        let decrust_err = DecrustError::Io {
            source: io_err,
            path: Some(path_buf),
            operation: "reading".to_string(),
            backtrace: Backtrace::generate(),
        };
        assert_eq!(
            decrust_err.to_string(),
            "I/O error during operation 'reading' on path '/my/file.txt': original os error"
        );
    }

    #[test]
    fn test_io_error_display_no_path() {
        let io_err = std::io::Error::new(std::io::ErrorKind::NotFound, "original os error");
        let decrust_err = DecrustError::Io {
            source: io_err,
            path: None,
            operation: "reading".to_string(),
            backtrace: Backtrace::generate(),
        };
        assert_eq!(
            decrust_err.to_string(),
            "I/O error during operation 'reading' on path 'N/A': original os error"
        );
    }

    #[test]
    fn test_error_recoverable() {
        let timeout_err = DecrustError::Timeout {
            operation: "test_op".to_string(),
            duration: Duration::from_secs(30),
            expected_duration: Some(Duration::from_secs(10)),
            backtrace: Backtrace::generate(),
        };
        assert!(timeout_err.is_recoverable());

        let parse_err = DecrustError::Parse {
            source: Box::new(std::io::Error::new(std::io::ErrorKind::InvalidData, "bad format")),
            kind: "JSON".to_string(),
            context_info: "Invalid JSON".to_string(),
            backtrace: Backtrace::generate(),
        };
        assert!(!parse_err.is_recoverable());
    }

    #[test]
    fn test_result_context_with_metadata() {
        let mut metadata = HashMap::new();
        metadata.insert("request_id".to_string(), "12345".to_string());
        metadata.insert("user_id".to_string(), "user_abc".to_string());

        let result: Result<(), std::io::Error> = Err(std::io::Error::new(
            std::io::ErrorKind::PermissionDenied,
            "Access denied",
        ));

        let result_with_context = result.decrust_context_with_metadata(
            "Failed to access resource",
            metadata.clone()
        );

        assert!(result_with_context.is_err());
        
        if let Err(DecrustError::WithRichContext { context, .. }) = result_with_context {
            assert_eq!(context.message, "Failed to access resource");
            assert_eq!(context.metadata.get("request_id"), Some(&"12345".to_string()));
            assert_eq!(context.metadata.get("user_id"), Some(&"user_abc".to_string()));
        } else {
            panic!("Expected WithRichContext error");
        }
    }

    #[test]
    fn test_optional_error_operations() {
        let opt_err = OptionalError::from_error(std::io::Error::new(
            std::io::ErrorKind::NotFound,
            "File not found"
        ));
        
        assert!(opt_err.has_error());
        assert!(opt_err.as_ref().is_some());
        
        let mapped = opt_err.map(|e| Box::new(std::io::Error::new(
            std::io::ErrorKind::Other,
            format!("Wrapped: {}", e)
        )) as Box<dyn std::error::Error + Send + Sync + 'static>);
        
        assert!(mapped.has_error());
        
        let none_err = OptionalError::none();
        assert!(!none_err.has_error());
    }
}