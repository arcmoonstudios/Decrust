
File: backtrace.rs
==================
/* src/backtrace.rs */
#![warn(missing_docs)]
//! **Brief:** Direct backtrace implementation with custom GenerateImplicitData trait.
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
//! + [Direct Backtrace System]
//!  - [Environment-Aware Capture]
//!  - [Custom GenerateImplicitData Trait]
//!  - [Crisis-Resistant Implementation]
//!  - [Zero External Dependencies]
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
// **GitHub:** [ArcMoon Studios](https://github.com/arcmoonstudios)
// **Copyright:** (c) 2025 ArcMoon Studios
// **Author:** Lord Xyn
// **License:** MIT

use std::env;
use std::fmt;
use std::sync::OnceLock;

/// Our own backtrace type that wraps std::backtrace::Backtrace
/// This provides crisis-resistant backtrace functionality
#[derive(Debug)]
pub struct DecrustBacktrace {
    inner: Option<std::backtrace::Backtrace>,
    capture_enabled: bool,
}

/// Status of backtrace capture
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum BacktraceStatus {
    /// Backtrace was successfully captured
    Captured,
    /// Backtrace capture was disabled by environment
    Disabled,
    /// Backtrace capture is not supported on this platform
    Unsupported,
}

impl DecrustBacktrace {
    /// Creates a new backtrace, respecting environment variables
    ///
    /// Checks RUST_LIB_BACKTRACE first, then RUST_BACKTRACE
    /// Only captures if set to "1" or "full"
    pub fn capture() -> Self {
        let should_capture = Self::should_capture_from_env();

        if should_capture {
            Self {
                inner: Some(std::backtrace::Backtrace::capture()),
                capture_enabled: true,
            }
        } else {
            Self {
                inner: None,
                capture_enabled: false,
            }
        }
    }

    /// Forces backtrace capture regardless of environment variables
    ///
    /// Use this when you need backtraces for debugging purposes
    pub fn force_capture() -> Self {
        Self {
            inner: Some(std::backtrace::Backtrace::force_capture()),
            capture_enabled: true,
        }
    }

    /// Creates a disabled backtrace (no capture)
    pub fn disabled() -> Self {
        Self {
            inner: None,
            capture_enabled: false,
        }
    }

    /// Returns the status of this backtrace
    pub fn status(&self) -> BacktraceStatus {
        match &self.inner {
            Some(bt) => match bt.status() {
                std::backtrace::BacktraceStatus::Captured => BacktraceStatus::Captured,
                std::backtrace::BacktraceStatus::Disabled => BacktraceStatus::Disabled,
                std::backtrace::BacktraceStatus::Unsupported => BacktraceStatus::Unsupported,
                _ => BacktraceStatus::Unsupported,
            },
            None => {
                if self.capture_enabled {
                    BacktraceStatus::Disabled
                } else {
                    BacktraceStatus::Disabled
                }
            }
        }
    }

    /// Check if backtrace should be captured based on environment variables
    fn should_capture_from_env() -> bool {
        static SHOULD_CAPTURE: OnceLock<bool> = OnceLock::new();

        *SHOULD_CAPTURE.get_or_init(|| {
            // Check RUST_LIB_BACKTRACE first (higher priority)
            if let Ok(val) = env::var("RUST_LIB_BACKTRACE") {
                return val == "1" || val.to_lowercase() == "full";
            }

            // Fall back to RUST_BACKTRACE
            if let Ok(val) = env::var("RUST_BACKTRACE") {
                return val == "1" || val.to_lowercase() == "full";
            }

            false
        })
    }

    /// Get the inner backtrace if available
    pub fn as_std_backtrace(&self) -> Option<&std::backtrace::Backtrace> {
        self.inner.as_ref()
    }
}

impl fmt::Display for DecrustBacktrace {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match &self.inner {
            Some(bt) => write!(f, "{}", bt),
            None => write!(f, "<backtrace disabled>"),
        }
    }
}

impl Clone for DecrustBacktrace {
    fn clone(&self) -> Self {
        // We can't clone the actual backtrace, so create a new one
        // with the same capture_enabled setting
        if self.capture_enabled {
            // Use force_capture to ensure we get a backtrace regardless of env vars
            Self {
                inner: Some(std::backtrace::Backtrace::force_capture()),
                capture_enabled: true,
            }
        } else {
            Self::disabled()
        }
    }
}

/// Trait for generating implicit data automatically
///
/// This replaces snafu's GenerateImplicitData trait with our own implementation
pub trait GenerateImplicitData {
    /// Generate the implicit data
    fn generate() -> Self;

    /// Generate implicit data with access to a source error
    ///
    /// Default implementation ignores the source and calls generate()
    fn generate_with_source(_source: &dyn std::error::Error) -> Self
    where
        Self: Sized,
    {
        Self::generate()
    }
}

/// Implementation for our backtrace type
impl GenerateImplicitData for DecrustBacktrace {
    fn generate() -> Self {
        Self::capture()
    }

    fn generate_with_source(source: &dyn std::error::Error) -> Self {
        // Check if the source already has a backtrace we can use
        // For now, just generate a new one, but this could be enhanced
        // to delegate to the source if it implements our backtrace trait
        let _ = source; // Suppress unused parameter warning for now
        Self::capture()
    }
}

// Add a static method to DecrustBacktrace for compatibility with code that expects generate()
impl DecrustBacktrace {
    /// Generate a new backtrace - compatibility method for code that expects generate()
    pub fn generate() -> Self {
        Self::capture()
    }
}

// Implement From<std::backtrace::Backtrace> for DecrustBacktrace
impl From<std::backtrace::Backtrace> for DecrustBacktrace {
    fn from(backtrace: std::backtrace::Backtrace) -> Self {
        Self {
            inner: Some(backtrace),
            capture_enabled: true,
        }
    }
}

/// Trait for types that can provide backtraces
///
/// This is our version of snafu's ErrorCompat trait
pub trait BacktraceCompat {
    /// Get the backtrace associated with this error, if any
    fn backtrace(&self) -> Option<&DecrustBacktrace>;
}

/// Extension trait for easier backtrace handling
pub trait BacktraceProvider {
    /// Get a backtrace from this error or any of its sources
    fn get_deepest_backtrace(&self) -> Option<&DecrustBacktrace>;
}

impl<E: std::error::Error + BacktraceCompat> BacktraceProvider for E {
    fn get_deepest_backtrace(&self) -> Option<&DecrustBacktrace> {
        // First check if this error has a backtrace
        if let Some(bt) = self.backtrace() {
            return Some(bt);
        }

        // Walk the error chain looking for backtraces
        let mut current = self.source();
        while let Some(err) = current {
            // Try to downcast to our BacktraceCompat trait
            // This is a bit tricky with trait objects, so for now
            // we'll just return None and let callers handle it
            current = err.source();
        }

        None
    }
}

/// Custom timestamp type that implements GenerateImplicitData
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Timestamp {
    instant: std::time::SystemTime,
}

impl Timestamp {
    /// Create a new timestamp with the current time
    pub fn now() -> Self {
        Self {
            instant: std::time::SystemTime::now(),
        }
    }

    /// Get the inner SystemTime
    pub fn as_system_time(&self) -> std::time::SystemTime {
        self.instant
    }
}

impl GenerateImplicitData for Timestamp {
    fn generate() -> Self {
        Self::now()
    }
}

impl fmt::Display for Timestamp {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.instant.duration_since(std::time::UNIX_EPOCH) {
            Ok(duration) => write!(f, "{}.{:03}", duration.as_secs(), duration.subsec_millis()),
            Err(_) => write!(f, "<invalid timestamp>"),
        }
    }
}

/// Thread ID type that implements GenerateImplicitData
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ThreadId {
    id: std::thread::ThreadId,
    name: Option<String>,
}

impl ThreadId {
    /// Get the current thread's ID and name
    pub fn current() -> Self {
        let thread = std::thread::current();
        Self {
            id: thread.id(),
            name: thread.name().map(|s| s.to_string()),
        }
    }

    /// Get the thread ID
    pub fn id(&self) -> std::thread::ThreadId {
        self.id
    }

    /// Get the thread name if available
    pub fn name(&self) -> Option<&str> {
        self.name.as_deref()
    }
}

impl GenerateImplicitData for ThreadId {
    fn generate() -> Self {
        Self::current()
    }
}

impl fmt::Display for ThreadId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match &self.name {
            Some(name) => write!(f, "{}({:?})", name, self.id),
            None => write!(f, "{:?}", self.id),
        }
    }
}

/// Location information for where an error was created
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Location {
    file: &'static str,
    line: u32,
    column: u32,
}

impl Location {
    /// Create a new location
    pub const fn new(file: &'static str, line: u32, column: u32) -> Self {
        Self { file, line, column }
    }

    /// Get the file path
    pub fn file(&self) -> &'static str {
        self.file
    }

    /// Get the line number
    pub fn line(&self) -> u32 {
        self.line
    }

    /// Get the column number
    pub fn column(&self) -> u32 {
        self.column
    }
}

impl fmt::Display for Location {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}:{}:{}", self.file, self.line, self.column)
    }
}

/// Macro to create a location at the current source position
#[macro_export]
macro_rules! location {
    () => {
        $crate::backtrace::Location::new(file!(), line!(), column!())
    };
}

/// Macro to generate implicit data at the call site
#[macro_export]
macro_rules! implicit_data {
    ($type:ty) => {
        <$type as $crate::backtrace::GenerateImplicitData>::generate()
    };
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_backtrace_creation() {
        let bt1 = DecrustBacktrace::capture();
        let bt2 = DecrustBacktrace::force_capture();
        let bt3 = DecrustBacktrace::disabled();

        // These should all be valid regardless of environment
        assert!(matches!(
            bt1.status(),
            BacktraceStatus::Captured | BacktraceStatus::Disabled
        ));
        assert!(
            bt2.status() == BacktraceStatus::Captured
                || bt2.status() == BacktraceStatus::Unsupported
        );
        assert_eq!(bt3.status(), BacktraceStatus::Disabled);
    }

    #[test]
    fn test_generate_implicit_data() {
        let bt = implicit_data!(DecrustBacktrace);
        let ts = implicit_data!(Timestamp);
        let tid = implicit_data!(ThreadId);

        // Just ensure they can be created
        assert!(matches!(
            bt.status(),
            BacktraceStatus::Captured | BacktraceStatus::Disabled
        ));
        assert!(ts.as_system_time() <= std::time::SystemTime::now());
        assert_eq!(tid.id(), std::thread::current().id());
    }

    #[test]
    fn test_location_macro() {
        let loc = location!();
        assert!(loc.file().ends_with("backtrace.rs"));
        assert!(loc.line() > 0);
        assert!(loc.column() > 0);
    }

    #[test]
    fn test_display_implementations() {
        let bt = DecrustBacktrace::disabled();
        let ts = Timestamp::now();
        let tid = ThreadId::current();
        let loc = location!();

        // These should all produce valid strings
        assert!(!bt.to_string().is_empty());
        assert!(!ts.to_string().is_empty());
        assert!(!tid.to_string().is_empty());
        assert!(!loc.to_string().is_empty());
    }

    #[test]
    fn test_clone_backtrace() {
        let bt1 = DecrustBacktrace::force_capture();
        let bt2 = bt1.clone();

        // Cloning should create a new backtrace with same capture settings
        assert_eq!(bt1.capture_enabled, bt2.capture_enabled);
    }
}

// ===== Snafu-basec Backtrace Compatibility Layer =====
/// Implementation of GenerateImplicitData for std::backtrace::Backtrace
impl crate::backtrace::GenerateImplicitData for std::backtrace::Backtrace {
    fn generate() -> Self {
        std::backtrace::Backtrace::force_capture()
    }
}

/// Trait for types that can provide a backtrace
///
/// This is our version of snafu's AsBacktrace trait
pub trait AsBacktrace {
    /// Get the backtrace associated with this error, if any
    fn as_backtrace(&self) -> Option<&std::backtrace::Backtrace>;
}

// Implementation for std::backtrace::Backtrace
impl AsBacktrace for std::backtrace::Backtrace {
    fn as_backtrace(&self) -> Option<&std::backtrace::Backtrace> {
        Some(self)
    }
}

// Implementation for our DecrustBacktrace
impl AsBacktrace for DecrustBacktrace {
    fn as_backtrace(&self) -> Option<&std::backtrace::Backtrace> {
        self.as_std_backtrace()
    }
}

// Example usage patterns for the library
#[cfg(test)]
mod usage_examples {
    use super::*;

    // Example error type using our backtrace system
    #[derive(Debug)]
    pub struct ExampleError {
        message: String,
        backtrace: DecrustBacktrace,
        timestamp: Timestamp,
        thread: ThreadId,
    }

    impl ExampleError {
        pub fn new(message: impl Into<String>) -> Self {
            Self {
                message: message.into(),
                backtrace: implicit_data!(DecrustBacktrace),
                timestamp: implicit_data!(Timestamp),
                thread: implicit_data!(ThreadId),
            }
        }
    }

    impl fmt::Display for ExampleError {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "{} [{}] [{}]", self.message, self.timestamp, self.thread)
        }
    }

    impl std::error::Error for ExampleError {}

    impl BacktraceCompat for ExampleError {
        fn backtrace(&self) -> Option<&DecrustBacktrace> {
            Some(&self.backtrace)
        }
    }

    #[test]
    fn test_example_error() {
        let err = ExampleError::new("Something went wrong");

        assert!(!err.to_string().is_empty());
        assert!(err.backtrace().is_some());

        // Test backtrace provider
        if let Some(bt) = err.get_deepest_backtrace() {
            assert!(matches!(
                bt.status(),
                BacktraceStatus::Captured | BacktraceStatus::Disabled
            ));
        }
    }
}



File: lib.rs
============
/* src/lib.rs */
#![warn(missing_docs)]
#![allow(stable_features)]
//! **Brief:** Main DecrustError enum with extensions and exports.
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
//! + [Error Handling Framework]
//!  - [Unified Error Type]
//!  - [Rich Error Context]
//!  - [Circuit Breaker Pattern]
//!  - [Error Reporting]
//!  - [Autocorrection Framework]
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
// **GitHub:** [ArcMoon Studios](https://github.com/arcmoonstudios)
// **Copyright:** (c) 2025 ArcMoon Studios
// **Author:** Lord Xyn
// **License:** MIT

pub mod backtrace;
pub mod circuit_breaker;
pub mod decrust;
pub mod reporter;
pub mod syntax;
pub mod types;

use std::path::PathBuf;
use std::time::Duration;

pub use self::backtrace::{
    DecrustBacktrace as Backtrace, // For Backtrace::generate()
    GenerateImplicitData,
    // FromString,                 // Will add back if `oops!` macro or FromString trait is used directly
    // ensure,                     // Will add back if used
};

pub use self::circuit_breaker::{
    CircuitBreaker, CircuitBreakerConfig, CircuitBreakerObserver, CircuitBreakerState,
};

pub use self::decrust::{
    AstMissingImportFixGenerator, AstUnusedCodeFixGenerator, AutocorrectableError,
    ClosureCaptureLifetimeFixGenerator, ConfigMissingKeyFixGenerator, ConfigSyntaxFixGenerator,
    Decrust, DivisionByZeroFixGenerator, InvalidArgumentCountFixGenerator,
    IoMissingDirectoryFixGenerator, IoPermissionFixGenerator, JsonParseFixGenerator,
    MissingOkErrFixGenerator, NetworkConnectionFixGenerator, NetworkTlsFixGenerator,
    QuestionMarkPropagationFixGenerator, RecursiveTypeFixGenerator,
    ReturnLocalReferenceFixGenerator, RuntimePanicFixGenerator, UnnecessaryCloneFixGenerator,
    UnnecessaryParenthesesFixGenerator, UnsafeUnwrapFixGenerator, UnstableFeatureFixGenerator,
    UnusedMutFixGenerator, YamlParseFixGenerator,
};

pub use self::reporter::{ErrorReportConfig, ErrorReporter};

pub use self::syntax::{FixTemplate, SyntaxGenerator, TemplateRegistry};

pub use self::types::{
    Autocorrection, ErrorCategory, ErrorContext, ErrorReportFormat, ErrorSeverity, ErrorSource,
    ExtractedParameters, FixDetails, FixType, ParameterExtractor, ParameterSource,
};

/// A Result type specialized for DecrustError
pub type Result<T, E = DecrustError> = std::result::Result<T, E>;

// Re-export key types from submodules
/// A Result type specialized for diagnostic operations that can return multiple errors
pub type DiagnosticResult<T> = std::result::Result<T, Vec<DecrustError>>;

/// Wrapper for `Option<Box<dyn Error>>` to make it compatible with backtrace
///
/// This struct provides a way to handle optional error sources in a way that's
/// compatible with the backtrace error handling framework. It wraps an optional boxed
/// error trait object and provides methods to work with it.
#[derive(Debug)]
pub struct OptionalError(pub Option<Box<dyn std::error::Error + Send + Sync + 'static>>);

impl Clone for OptionalError {
    fn clone(&self) -> Self {
        match &self.0 {
            Some(err) => {
                // Create a new error with the string representation of the original error
                let cloned_err = std::io::Error::new(std::io::ErrorKind::Other, format!("{}", err));
                OptionalError(Some(Box::new(cloned_err)))
            }
            None => OptionalError(None),
        }
    }
}

impl std::fmt::Display for OptionalError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.0 {
            Some(err) => write!(f, "{}", err),
            None => write!(f, "No error"),
        }
    }
}

impl std::error::Error for OptionalError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.0 {
            Some(err) => Some(err.as_ref()),
            None => None,
        }
    }
}

// Implement BacktraceCompat for DecrustError to make backtrace() work
// Implement std::error::Error for DecrustError
impl std::error::Error for DecrustError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            DecrustError::Io { source, .. } => Some(source),
            DecrustError::WithRichContext { source, .. } => Some(source.as_ref()),
            DecrustError::Oops { source, .. } => Some(source.as_ref()),
            DecrustError::Parse { source, .. } => Some(source.as_ref()),
            DecrustError::Network { source, .. } => Some(source.as_ref()),
            DecrustError::Config { source, .. } => source
                .0
                .as_ref()
                .map(|e| e.as_ref() as &(dyn std::error::Error + 'static)),
            DecrustError::Internal { source, .. } => source
                .0
                .as_ref()
                .map(|e| e.as_ref() as &(dyn std::error::Error + 'static)),
            DecrustError::Concurrency { source, .. } => source
                .0
                .as_ref()
                .map(|e| e.as_ref() as &(dyn std::error::Error + 'static)),
            DecrustError::ExternalService { source, .. } => source
                .0
                .as_ref()
                .map(|e| e.as_ref() as &(dyn std::error::Error + 'static)),
            DecrustError::MultipleErrors { errors, .. } => errors
                .first()
                .map(|e| e as &(dyn std::error::Error + 'static)),
            DecrustError::CircuitBreakerOpen { .. } => None,
            DecrustError::ResourceExhausted { .. } => None,
            DecrustError::StateConflict { .. } => None,
            DecrustError::MissingValue { .. } => None,
            DecrustError::Validation { .. } => None,
            DecrustError::NotFound { .. } => None,
            DecrustError::Timeout { .. } => None,
            DecrustError::Style { .. } => None,
        }
    }
}

// Implement PartialEq for DecrustError to support testing
impl PartialEq for DecrustError {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (DecrustError::Parse { kind: k1, .. }, DecrustError::Parse { kind: k2, .. }) => {
                k1 == k2
            }
            (DecrustError::Oops { message: m1, .. }, DecrustError::Oops { message: m2, .. }) => {
                m1 == m2
            }
            (DecrustError::Network { kind: k1, .. }, DecrustError::Network { kind: k2, .. }) => {
                k1 == k2
            }
            (DecrustError::Style { message: m1, .. }, DecrustError::Style { message: m2, .. }) => {
                m1 == m2
            }
            (
                DecrustError::Config { message: m1, .. },
                DecrustError::Config { message: m2, .. },
            ) => m1 == m2,
            (DecrustError::Io { operation: op1, .. }, DecrustError::Io { operation: op2, .. }) => {
                op1 == op2
            }
            (
                DecrustError::Internal { message: m1, .. },
                DecrustError::Internal { message: m2, .. },
            ) => m1 == m2,
            (
                DecrustError::Concurrency { message: m1, .. },
                DecrustError::Concurrency { message: m2, .. },
            ) => m1 == m2,
            (
                DecrustError::Timeout { operation: op1, .. },
                DecrustError::Timeout { operation: op2, .. },
            ) => op1 == op2,
            (
                DecrustError::StateConflict { message: m1, .. },
                DecrustError::StateConflict { message: m2, .. },
            ) => m1 == m2,
            (
                DecrustError::CircuitBreakerOpen { name: n1, .. },
                DecrustError::CircuitBreakerOpen { name: n2, .. },
            ) => n1 == n2,
            (
                DecrustError::ResourceExhausted { resource: r1, .. },
                DecrustError::ResourceExhausted { resource: r2, .. },
            ) => r1 == r2,
            (
                DecrustError::ExternalService {
                    service_name: s1, ..
                },
                DecrustError::ExternalService {
                    service_name: s2, ..
                },
            ) => s1 == s2,
            (
                DecrustError::MissingValue {
                    item_description: i1,
                    ..
                },
                DecrustError::MissingValue {
                    item_description: i2,
                    ..
                },
            ) => i1 == i2,
            (
                DecrustError::MultipleErrors { errors: e1, .. },
                DecrustError::MultipleErrors { errors: e2, .. },
            ) => e1 == e2,
            (
                DecrustError::Validation {
                    field: f1,
                    message: m1,
                    ..
                },
                DecrustError::Validation {
                    field: f2,
                    message: m2,
                    ..
                },
            ) => f1 == f2 && m1 == m2,
            (
                DecrustError::NotFound {
                    resource_type: r1,
                    identifier: i1,
                    ..
                },
                DecrustError::NotFound {
                    resource_type: r2,
                    identifier: i2,
                    ..
                },
            ) => r1 == r2 && i1 == i2,
            (
                DecrustError::WithRichContext {
                    context: c1,
                    source: s1,
                },
                DecrustError::WithRichContext {
                    context: c2,
                    source: s2,
                },
            ) => c1.message == c2.message && s1 == s2,
            _ => false,
        }
    }
}

impl backtrace::BacktraceCompat for DecrustError {
    fn backtrace(&self) -> Option<&backtrace::DecrustBacktrace> {
        match self {
            DecrustError::Io { backtrace, .. } => Some(backtrace),
            DecrustError::Oops { backtrace, .. } => Some(backtrace),
            DecrustError::Style { backtrace, .. } => Some(backtrace),
            DecrustError::Parse { backtrace, .. } => Some(backtrace),
            DecrustError::Config { backtrace, .. } => Some(backtrace),
            DecrustError::Timeout { backtrace, .. } => Some(backtrace),
            DecrustError::Network { backtrace, .. } => Some(backtrace),
            DecrustError::NotFound { backtrace, .. } => Some(backtrace),
            DecrustError::Internal { backtrace, .. } => Some(backtrace),
            DecrustError::Validation { backtrace, .. } => Some(backtrace),
            DecrustError::Concurrency { backtrace, .. } => Some(backtrace),
            DecrustError::MissingValue { backtrace, .. } => Some(backtrace),
            DecrustError::StateConflict { backtrace, .. } => Some(backtrace),
            DecrustError::MultipleErrors { backtrace, .. } => Some(backtrace),
            DecrustError::ExternalService { backtrace, .. } => Some(backtrace),
            DecrustError::ResourceExhausted { backtrace, .. } => Some(backtrace),
            DecrustError::CircuitBreakerOpen { backtrace, .. } => Some(backtrace),
            DecrustError::WithRichContext { source, .. } => source.backtrace(),
        }
    }
}

impl OptionalError {
    /// Creates a new OptionalError from an optional boxed error
    ///
    /// # Parameters
    /// * `opt` - An optional boxed error trait object
    pub fn new(opt: Option<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        OptionalError(opt)
    }

    /// Checks if this OptionalError contains an actual error
    ///
    /// # Returns
    /// `true` if there is an error, `false` otherwise
    pub fn has_error(&self) -> bool {
        self.0.is_some()
    }
}

impl From<Option<Box<dyn std::error::Error + Send + Sync + 'static>>> for OptionalError {
    fn from(opt: Option<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        OptionalError(opt)
    }
}

impl AsRef<Option<Box<dyn std::error::Error + Send + Sync + 'static>>> for OptionalError {
    fn as_ref(&self) -> &Option<Box<dyn std::error::Error + Send + Sync + 'static>> {
        &self.0
    }
}

/// Unified error type for Decrust.
#[derive(Debug)]
pub enum DecrustError {
    /// I/O related errors
    Io {
        /// The underlying I/O error
        source: std::io::Error,
        /// Optional path to the file or resource that caused the error
        path: Option<PathBuf>,
        /// Description of the operation that failed
        operation: String,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Parsing errors (JSON, YAML, etc.)
    Parse {
        /// The underlying parsing error
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        /// The type of data being parsed (e.g., "JSON", "YAML")
        kind: String,
        /// Additional context information about the parsing operation
        context_info: String,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Network related errors
    Network {
        /// The underlying network error
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        /// Optional URL that was being accessed
        url: Option<String>,
        /// The type of network operation (e.g., "HTTP", "TCP")
        kind: String,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Configuration related errors
    Config {
        /// Error message describing the configuration issue
        message: String,
        /// Optional path to the configuration file
        path: Option<PathBuf>,
        /// Optional underlying error that caused the configuration issue
        source: OptionalError,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Validation errors
    Validation {
        /// Name of the field that failed validation
        field: String,
        /// Description of the validation error
        message: String,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Internal errors
    Internal {
        /// Description of the internal error
        message: String,
        /// Optional underlying error
        source: OptionalError,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Circuit breaker is open
    CircuitBreakerOpen {
        /// Name of the circuit breaker
        name: String,
        /// Optional duration after which the circuit breaker might transition to half-open
        retry_after: Option<Duration>,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Operation timed out
    Timeout {
        /// Name of the operation that timed out
        operation: String,
        /// Duration after which the operation timed out
        duration: Duration,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Resource exhaustion
    ResourceExhausted {
        /// Name of the resource that was exhausted
        resource: String,
        /// The limit of the resource
        limit: String,
        /// The current value that exceeded the limit
        current: String,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Resource not found
    NotFound {
        /// Type of resource that was not found (e.g., "User", "File")
        resource_type: String,
        /// Identifier of the resource that was not found
        identifier: String,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// State conflict
    StateConflict {
        /// Description of the state conflict
        message: String,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Concurrency related errors
    Concurrency {
        /// Description of the concurrency error
        message: String,
        /// Optional underlying error
        source: OptionalError,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// External service errors
    ExternalService {
        /// Name of the external service that caused the error
        service_name: String,
        /// Description of the error from the external service
        message: String,
        /// Optional underlying error from the external service
        source: OptionalError,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Missing value errors
    MissingValue {
        /// Description of the missing value or item
        item_description: String,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Multiple errors
    MultipleErrors {
        /// Collection of errors that occurred
        errors: Vec<DecrustError>,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// Error with rich context
    WithRichContext {
        /// Rich context information attached to the error
        context: types::ErrorContext,
        /// The original error that is being wrapped with context
        source: Box<DecrustError>,
    },

    /// Style and formatting errors
    Style {
        /// The style error message
        message: String,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },

    /// General purpose error wrapper
    Oops {
        /// Custom error message
        message: String,
        /// The underlying error being wrapped
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        /// Backtrace captured at the error site
        backtrace: Backtrace,
    },
}

impl Clone for DecrustError {
    fn clone(&self) -> Self {
        match self {
            Self::Io {
                source,
                path,
                operation,
                ..
            } => Self::Io {
                source: std::io::Error::new(source.kind(), format!("{}", source)),
                path: path.clone(),
                operation: operation.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::Parse {
                source,
                kind,
                context_info,
                ..
            } => Self::Parse {
                source: Box::new(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!("{}", source),
                )),
                kind: kind.clone(),
                context_info: context_info.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::Network {
                source, url, kind, ..
            } => Self::Network {
                source: Box::new(std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!("{}", source),
                )),
                url: url.clone(),
                kind: kind.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::Config {
                message,
                path,
                source,
                ..
            } => Self::Config {
                message: message.clone(),
                path: path.clone(),
                source: source.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::Validation { field, message, .. } => Self::Validation {
                field: field.clone(),
                message: message.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::Internal {
                message, source, ..
            } => Self::Internal {
                message: message.clone(),
                source: source.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::CircuitBreakerOpen {
                name, retry_after, ..
            } => Self::CircuitBreakerOpen {
                name: name.clone(),
                retry_after: *retry_after,
                backtrace: Backtrace::generate(),
            },
            Self::Timeout {
                operation,
                duration,
                ..
            } => Self::Timeout {
                operation: operation.clone(),
                duration: *duration,
                backtrace: Backtrace::generate(),
            },
            Self::ResourceExhausted {
                resource,
                limit,
                current,
                ..
            } => Self::ResourceExhausted {
                resource: resource.clone(),
                limit: limit.clone(),
                current: current.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::NotFound {
                resource_type,
                identifier,
                ..
            } => Self::NotFound {
                resource_type: resource_type.clone(),
                identifier: identifier.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::StateConflict { message, .. } => Self::StateConflict {
                message: message.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::Concurrency {
                message, source, ..
            } => Self::Concurrency {
                message: message.clone(),
                source: source.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::ExternalService {
                service_name,
                message,
                source,
                ..
            } => Self::ExternalService {
                service_name: service_name.clone(),
                message: message.clone(),
                source: source.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::MissingValue {
                item_description, ..
            } => Self::MissingValue {
                item_description: item_description.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::MultipleErrors { errors, .. } => Self::MultipleErrors {
                errors: errors.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::WithRichContext { context, source } => {
                // Explicitly list fields, no 'backtrace' field here
                Self::WithRichContext {
                    context: context.clone(),
                    source: Box::new((**source).clone()),
                }
            }
            Self::Style { message, .. } => Self::Style {
                message: message.clone(),
                backtrace: Backtrace::generate(),
            },
            Self::Oops {
                message, source, ..
            } => Self::Oops {
                message: message.clone(),
                source: Box::new(std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!("{}", source),
                )),
                backtrace: Backtrace::generate(),
            },
        }
    }
}

impl std::fmt::Display for DecrustError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DecrustError::Io {
                source,
                path,
                operation,
                ..
            } => {
                write!(
                    f,
                    "I/O error during operation '{}' on path '{}': {}",
                    operation,
                    path.as_ref()
                        .map(|p| p.to_string_lossy().to_string())
                        .unwrap_or_else(|| "N/A".to_string()),
                    source
                )
            }
            DecrustError::Parse {
                source,
                kind,
                context_info,
                ..
            } => {
                write!(f, "{} parsing error: {} ({})", kind, source, context_info)
            }
            DecrustError::Network {
                source, url, kind, ..
            } => {
                write!(
                    f,
                    "{} network error: {} (URL: {})",
                    kind,
                    source,
                    url.as_deref().unwrap_or("N/A")
                )
            }
            DecrustError::Config {
                message,
                path,
                source,
                ..
            } => {
                if let Some(p) = path {
                    if let Some(s) = &source.0 {
                        write!(
                            f,
                            "Configuration error in '{}': {} ({})",
                            p.display(),
                            message,
                            s
                        )
                    } else {
                        write!(f, "Configuration error in '{}': {}", p.display(), message)
                    }
                } else if let Some(s) = &source.0 {
                    write!(f, "Configuration error: {} ({})", message, s)
                } else {
                    write!(f, "Configuration error: {}", message)
                }
            }
            DecrustError::Validation { field, message, .. } => {
                write!(f, "Validation error for '{}': {}", field, message)
            }
            DecrustError::Internal {
                message, source, ..
            } => {
                if let Some(s) = &source.0 {
                    write!(f, "Internal error: {} ({})", message, s)
                } else {
                    write!(f, "Internal error: {}", message)
                }
            }
            DecrustError::CircuitBreakerOpen {
                name, retry_after, ..
            } => {
                if let Some(duration) = retry_after {
                    write!(
                        f,
                        "Circuit breaker '{}' is open. Retry after {:?}",
                        name, duration
                    )
                } else {
                    write!(f, "Circuit breaker '{}' is open", name)
                }
            }
            DecrustError::Timeout {
                operation,
                duration,
                ..
            } => {
                write!(
                    f,
                    "Operation '{}' timed out after {:?}",
                    operation, duration
                )
            }
            DecrustError::ResourceExhausted {
                resource,
                limit,
                current,
                ..
            } => {
                write!(
                    f,
                    "Resource '{}' exhausted: {} (limit: {})",
                    resource, current, limit
                )
            }
            DecrustError::NotFound {
                resource_type,
                identifier,
                ..
            } => {
                write!(f, "{} not found: {}", resource_type, identifier)
            }
            DecrustError::StateConflict { message, .. } => {
                write!(f, "State conflict: {}", message)
            }
            DecrustError::Concurrency {
                message, source, ..
            } => {
                if let Some(s) = &source.0 {
                    write!(f, "Concurrency error: {} ({})", message, s)
                } else {
                    write!(f, "Concurrency error: {}", message)
                }
            }
            DecrustError::ExternalService {
                service_name,
                message,
                source,
                ..
            } => {
                if let Some(s) = &source.0 {
                    write!(
                        f,
                        "External service '{}' error: {} ({})",
                        service_name, message, s
                    )
                } else {
                    write!(f, "External service '{}' error: {}", service_name, message)
                }
            }
            DecrustError::MissingValue {
                item_description, ..
            } => {
                write!(f, "Missing value: {}", item_description)
            }
            DecrustError::MultipleErrors { errors, .. } => {
                write!(f, "Multiple errors ({} total):", errors.len())?;
                for (i, err) in errors.iter().enumerate() {
                    write!(f, "\n  {}. {}", i + 1, err)?;
                }
                Ok(())
            }
            DecrustError::WithRichContext {
                context, source, ..
            } => {
                write!(f, "{}: {}", context.message, source)
            }
            DecrustError::Style { message, .. } => {
                write!(f, "Style issue: {}", message)
            }
            DecrustError::Oops {
                message, source, ..
            } => {
                write!(f, "{}: {}", message, source)
            }
        }
    }
}

impl DecrustError {
    /// Adds rich context to an error
    ///
    /// This wraps the error in a WithRichContext variant, which allows for additional
    /// information to be attached to the error.
    ///
    /// # Parameters
    /// * `context` - The error context to add
    ///
    /// # Returns
    /// A new error with the context attached
    pub fn add_context(self, context: types::ErrorContext) -> Self {
        // Create the WithRichContext variant directly
        DecrustError::WithRichContext {
            context,
            source: Box::new(self),
        }
    }

    /// Adds a simple message context to an error
    ///
    /// This is a convenience method that creates a simple ErrorContext with just a message
    /// and adds it to the error.
    ///
    /// # Parameters
    /// * `message` - The message to add as context
    ///
    /// # Returns
    /// A new error with the context attached
    pub fn add_context_msg(self, message: impl Into<String>) -> Self {
        let error_context = types::ErrorContext::new(message);
        self.add_context(error_context)
    }

    /// Gets the category of this error
    ///
    /// # Returns
    /// The ErrorCategory that best describes this error
    pub fn category(&self) -> types::ErrorCategory {
        match self {
            DecrustError::Io { .. } => types::ErrorCategory::Io,
            DecrustError::Parse { .. } => types::ErrorCategory::Parsing,
            DecrustError::Network { .. } => types::ErrorCategory::Network,
            DecrustError::Config { .. } => types::ErrorCategory::Configuration,
            DecrustError::Validation { .. } => types::ErrorCategory::Validation,
            DecrustError::Internal { .. } => types::ErrorCategory::Internal,
            DecrustError::CircuitBreakerOpen { .. } => types::ErrorCategory::CircuitBreaker,
            DecrustError::Timeout { .. } => types::ErrorCategory::Timeout,
            DecrustError::ResourceExhausted { .. } => types::ErrorCategory::ResourceExhaustion,
            DecrustError::NotFound { .. } => types::ErrorCategory::NotFound,
            DecrustError::StateConflict { .. } => types::ErrorCategory::StateConflict,
            DecrustError::Concurrency { .. } => types::ErrorCategory::Concurrency,
            DecrustError::ExternalService { .. } => types::ErrorCategory::ExternalService,
            DecrustError::MultipleErrors { .. } => types::ErrorCategory::Multiple,
            DecrustError::WithRichContext { source, .. } => source.category(),
            DecrustError::Style { .. } => types::ErrorCategory::Style,
            DecrustError::Oops { .. } => types::ErrorCategory::Unspecified,
            DecrustError::MissingValue { .. } => types::ErrorCategory::Validation,
        }
    }

    /// Gets the severity of this error
    ///
    /// # Returns
    /// The ErrorSeverity level of this error
    pub fn severity(&self) -> types::ErrorSeverity {
        if let DecrustError::WithRichContext { context, .. } = self {
            context.severity
        } else {
            types::ErrorSeverity::Error
        }
    }

    /// Gets the rich context attached to this error, if any
    ///
    /// # Returns
    /// Some(context) if this is a WithRichContext error, None otherwise
    pub fn get_rich_context(&self) -> Option<&types::ErrorContext> {
        match self {
            DecrustError::WithRichContext { context, .. } => Some(context),
            _ => None,
        }
    }
}

/// Extension trait for Result types to add context to errors
///
/// This trait provides methods to add context to errors in a Result,
/// making it easier to provide additional information about the error.
pub trait DecrustResultExt<T, EOrig> {
    /// Adds a simple message context to an error in a Result
    ///
    /// # Parameters
    /// * `message` - The message to add as context
    ///
    /// # Returns
    /// A new Result with the error wrapped in a WithRichContext variant if it was an error
    fn decrust_context_msg(self, message: impl Into<String>) -> Result<T, DecrustError>;

    /// Adds rich context to an error in a Result
    ///
    /// # Parameters
    /// * `context` - The error context to add
    ///
    /// # Returns
    /// A new Result with the error wrapped in a WithRichContext variant if it was an error
    fn decrust_context_rich(self, context: types::ErrorContext) -> Result<T, DecrustError>;
}

impl<T, E> DecrustResultExt<T, E> for std::result::Result<T, E>
where
    E: Into<DecrustError>,
{
    #[track_caller]
    fn decrust_context_msg(self, message: impl Into<String>) -> Result<T, DecrustError> {
        match self {
            Ok(value) => Ok(value),
            Err(err) => {
                let decrust_err: DecrustError = err.into();
                Err(DecrustError::WithRichContext {
                    context: types::ErrorContext::new(message),
                    source: Box::new(decrust_err),
                })
            }
        }
    }

    #[track_caller]
    fn decrust_context_rich(self, context: types::ErrorContext) -> Result<T, DecrustError> {
        match self {
            Ok(value) => Ok(value),
            Err(err) => {
                let decrust_err: DecrustError = err.into();
                Err(DecrustError::WithRichContext {
                    context,
                    source: Box::new(decrust_err),
                })
            }
        }
    }
}

/// Extension trait for Option types to convert to Result with DecrustError
///
/// This trait provides methods to convert an Option to a Result, with a MissingValue
/// error if the Option is None.
pub trait DecrustOptionExt<T> {
    /// Converts an Option to a Result, with a MissingValue error if None
    ///
    /// # Parameters
    /// * `item_description` - Description of the missing value for the error message
    ///
    /// # Returns
    /// Ok(value) if the Option is Some(value), Err(DecrustError::MissingValue) otherwise
    fn decrust_ok_or_missing_value(
        self,
        item_description: impl Into<String>,
    ) -> Result<T, DecrustError>;
}

impl<T> DecrustOptionExt<T> for Option<T> {
    #[track_caller]
    fn decrust_ok_or_missing_value(
        self,
        item_description: impl Into<String>,
    ) -> Result<T, DecrustError> {
        match self {
            Some(v) => Ok(v),
            None => Err(DecrustError::MissingValue {
                item_description: item_description.into(),
                backtrace: Backtrace::generate(),
            }),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use backtrace::BacktraceCompat; // Ensure BacktraceCompat is in scope for tests
                                    // GenerateImplicitData is not needed in tests unless you call Backtrace::generate() directly.

    #[test]
    fn test_error_creation_and_context() {
        let source_opt: Option<Box<dyn std::error::Error + Send + Sync + 'static>> = None;
        // Create the error directly
        let err = DecrustError::Internal {
            message: "Test error".to_string(),
            source: OptionalError(source_opt),
            backtrace: Backtrace::generate(),
        };

        assert_eq!(err.category(), types::ErrorCategory::Internal);

        // Create a Result with the error and use the extension trait
        let err_with_context_res: Result<(), DecrustError> =
            Err(err).decrust_context_msg("Additional context");
        assert!(err_with_context_res.is_err());
        let err_with_context = err_with_context_res.unwrap_err();

        if let DecrustError::WithRichContext {
            context, source, ..
        } = &err_with_context
        {
            assert_eq!(context.message, "Additional context");
            // source is &Box<DecrustError>, so we need to dereference it properly
            if let DecrustError::Internal { message, .. } = source.as_ref() {
                assert_eq!(message, "Test error");
            } else {
                panic!("Expected Internal error variant, got {:?}", source);
            }
        } else {
            panic!(
                "Expected WithRichContext error variant, got {:?}",
                err_with_context
            );
        }
    }

    #[test]
    fn test_error_clone() {
        let io_err_orig = std::io::Error::new(std::io::ErrorKind::NotFound, "File not found");
        let original_err = DecrustError::Io {
            source: io_err_orig,
            path: Some(PathBuf::from("/path/to/file")),
            operation: "read_file".to_string(),
            backtrace: Backtrace::generate(),
        };

        let cloned_err = original_err.clone();

        assert_eq!(cloned_err.category(), types::ErrorCategory::Io);

        // Use `ref` for non-Copy fields in pattern to avoid moving
        if let DecrustError::Io {
            ref path,
            ref operation,
            ref source,
            ..
        } = cloned_err
        {
            assert_eq!(*path, Some(PathBuf::from("/path/to/file")));
            assert_eq!(*operation, "read_file");
            assert_eq!(source.kind(), std::io::ErrorKind::NotFound);
        } else {
            panic!("Expected Io error variant");
        }
        assert!(BacktraceCompat::backtrace(&cloned_err).is_some());
    }

    #[test]
    fn test_option_ext() {
        let opt_value: Option<i32> = Some(42);
        let result = opt_value.decrust_ok_or_missing_value("test value");
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 42);

        let opt_none: Option<i32> = None;
        let result = opt_none.decrust_ok_or_missing_value("test value");
        assert!(result.is_err());

        if let Err(DecrustError::MissingValue {
            item_description, ..
        }) = result
        {
            assert_eq!(item_description, "test value");
        } else {
            panic!("Expected MissingValue error variant");
        }
    }

    #[test]
    fn test_multiple_errors() {
        // Create validation errors directly
        let err1 = DecrustError::Validation {
            field: "username".to_string(),
            message: "Username too short".to_string(),
            backtrace: Backtrace::generate(),
        };

        let err2 = DecrustError::Validation {
            field: "password".to_string(),
            message: "Password too weak".to_string(),
            backtrace: Backtrace::generate(),
        };

        // Create multiple errors directly
        let multi_err = DecrustError::MultipleErrors {
            errors: vec![err1, err2.clone()],
            backtrace: Backtrace::generate(),
        };

        if let DecrustError::MultipleErrors { errors, .. } = multi_err {
            assert_eq!(errors.len(), 2);
            if let DecrustError::Validation { field, .. } = &errors[0] {
                assert_eq!(field, "username");
            } else {
                panic!("Expected Validation error variant for errors[0]");
            }
            if let DecrustError::Validation { field, .. } = &errors[1] {
                assert_eq!(field, "password");
            } else {
                panic!("Expected Validation error variant for errors[1]");
            }
        } else {
            panic!("Expected MultipleErrors error variant");
        }
    }

    #[test]
    fn test_whatever_error() {
        let original_io_error = std::io::Error::new(std::io::ErrorKind::Other, "some io problem");
        // Create a Oops variant directly
        let err = DecrustError::Oops {
            message: "A oops message".to_string(),
            source: Box::new(original_io_error)
                as Box<dyn std::error::Error + Send + Sync + 'static>,
            backtrace: Backtrace::generate(),
        };

        if let DecrustError::Oops {
            message, source, ..
        } = err
        {
            // Use .. for backtrace if not asserted
            assert_eq!(message, "A oops message");
            assert_eq!(source.to_string(), "some io problem");
        } else {
            panic!("Expected Oops error variant");
        }
    }

    #[test]
    fn test_io_error_display() {
        let path_buf = PathBuf::from("/my/file.txt");
        let io_err = std::io::Error::new(std::io::ErrorKind::NotFound, "original os error");
        let ak_err = DecrustError::Io {
            source: io_err,
            path: Some(path_buf),
            operation: "reading".to_string(),
            backtrace: Backtrace::generate(),
        };
        assert_eq!(
            ak_err.to_string(),
            "I/O error during operation 'reading' on path '/my/file.txt': original os error"
        );
    }

    #[test]
    fn test_io_error_display_no_path() {
        let io_err = std::io::Error::new(std::io::ErrorKind::NotFound, "original os error");
        let ak_err = DecrustError::Io {
            source: io_err,
            path: None,
            operation: "reading".to_string(),
            backtrace: Backtrace::generate(),
        };
        assert_eq!(
            ak_err.to_string(),
            "I/O error during operation 'reading' on path 'N/A': original os error"
        );
    }
}



File: reporter.rs
=================
/* src/common/error/reporter.rs */
#![warn(missing_docs)]
//! **Brief:** Error reporting utilities for structured error displays.
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
//! + [Error Handling Framework]
//!  - [Error Reporting]
//!  - [Formatted Output]
//!  - [Diagnostic Presentation]
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
// **GitHub:** [ArcMoon Studios](https://github.com/arcmoonstudios)
// **Copyright:** (c) 2025 ArcMoon Studios
// **Author:** Lord Xyn
// **License:** MIT

use super::types::ErrorReportFormat;
use std::io::{self, Write};

/// Configuration for the error reporter
#[derive(Debug, Clone)]
pub struct ErrorReportConfig {
    /// Whether to include the main error message in the report
    pub include_message: bool,
    /// Whether to include the chain of source errors in the report
    pub include_source_chain: bool,
    /// Whether to include backtrace information in the report
    pub include_backtrace: bool,
    /// Whether to include rich context information in the report
    pub include_rich_context: bool,
    /// Whether to include source code location information in the report
    pub include_source_location: bool,
    /// Whether to include error severity information in the report
    pub include_severity: bool,
    /// The output format for the error report
    pub format: ErrorReportFormat,
    /// Maximum depth of the error source chain to include (None for unlimited)
    pub max_chain_depth: Option<usize>,
    /// Whether to format JSON output with indentation and line breaks
    pub pretty_print_json: bool,
    /// Whether to include diagnostic information in the report
    pub include_diagnostics: bool,
}

impl Default for ErrorReportConfig {
    fn default() -> Self {
        Self {
            include_message: true,
            include_source_chain: true,
            include_backtrace: true,
            include_rich_context: true,
            include_source_location: true,
            include_severity: true,
            format: ErrorReportFormat::Plain,
            max_chain_depth: None,
            pretty_print_json: true,
            include_diagnostics: true,
        }
    }
}

/// Utility for generating formatted error reports
#[derive(Debug, Default)]
pub struct ErrorReporter;

impl ErrorReporter {
    /// Creates a new ErrorReporter instance
    ///
    /// This is a simple constructor that returns a new instance of the ErrorReporter.
    /// Since ErrorReporter has no state, this is equivalent to using the Default implementation.
    pub fn new() -> Self {
        Self
    }

    /// Report an error to a writer using the provided configuration
    pub fn report<W, E>(
        &self,
        error: &E,
        config: &ErrorReportConfig,
        writer: &mut W,
    ) -> io::Result<()>
    where
        W: Write,
        E: std::error::Error,
    {
        match config.format {
            ErrorReportFormat::Plain => self.report_plain(error, config, writer),
            ErrorReportFormat::Json => self.report_json(error, config, writer),
            ErrorReportFormat::Markdown => self.report_markdown(error, config, writer),
            ErrorReportFormat::Html => self.report_html(error, config, writer),
        }
    }

    /// Report an error with syntax highlighting and AST-aware formatting
    ///
    /// This method provides enhanced error reporting with syntax highlighting,
    /// code snippets, and AST-aware formatting for better readability.
    ///
    /// # Parameters
    /// * `error` - The error to report
    /// * `config` - Configuration for the error report
    /// * `source_code` - Optional source code context
    /// * `writer` - The writer to output the report to
    ///
    /// # Returns
    /// IO result indicating success or failure
    pub fn report_with_syntax<W, E>(
        &self,
        error: &E,
        config: &ErrorReportConfig,
        source_code: Option<&str>,
        writer: &mut W,
    ) -> io::Result<()>
    where
        W: Write,
        E: std::error::Error,
    {
        // First write the standard error report
        self.report(error, config, writer)?;

        // If we have source code context, add syntax-highlighted code snippets
        if let Some(code) = source_code {
            match config.format {
                ErrorReportFormat::Plain => {
                    writeln!(writer, "\nSource Code Context:")?;
                    writeln!(writer, "-------------------")?;

                    // Simple line-by-line output for plain text
                    for (i, line) in code.lines().enumerate() {
                        writeln!(writer, "{:4} | {}", i + 1, line)?;
                    }
                }
                ErrorReportFormat::Markdown => {
                    writeln!(writer, "\n### Source Code Context\n")?;
                    writeln!(writer, "```rust")?;
                    writeln!(writer, "{}", code)?;
                    writeln!(writer, "```")?;
                }
                ErrorReportFormat::Html => {
                    writeln!(writer, "<h3>Source Code Context</h3>")?;
                    writeln!(writer, "<pre class=\"code rust\">")?;

                    // Escape HTML special characters
                    let escaped_code = code
                        .replace("&", "&amp;")
                        .replace("<", "&lt;")
                        .replace(">", "&gt;");

                    writeln!(writer, "{}", escaped_code)?;
                    writeln!(writer, "</pre>")?;
                }
                ErrorReportFormat::Json => {
                    // For JSON, we need to modify the existing JSON output
                    // This is a simplified approach - in a real implementation,
                    // we would use a proper JSON library
                    let escaped_code = code.replace("\"", "\\\"").replace("\n", "\\n");
                    writeln!(writer, "{{ \"source_code\": \"{}\" }}", escaped_code)?;
                }
            }
        }

        Ok(())
    }

    /// Report an error as a string using the provided configuration
    pub fn report_to_string<E>(&self, error: &E, config: &ErrorReportConfig) -> String
    where
        E: std::error::Error,
    {
        let mut buffer = Vec::new();
        let _ = self.report(error, config, &mut buffer);
        String::from_utf8_lossy(&buffer).to_string()
    }

    /// Report an error as a string with syntax highlighting and AST-aware formatting
    ///
    /// # Parameters
    /// * `error` - The error to report
    /// * `config` - Configuration for the error report
    /// * `source_code` - Optional source code context
    ///
    /// # Returns
    /// The formatted error report as a string
    pub fn report_to_string_with_syntax<E>(
        &self,
        error: &E,
        config: &ErrorReportConfig,
        source_code: Option<&str>,
    ) -> String
    where
        E: std::error::Error,
    {
        let mut buffer = Vec::new();
        let _ = self.report_with_syntax(error, config, source_code, &mut buffer);
        String::from_utf8_lossy(&buffer).to_string()
    }

    fn report_plain<W, E>(
        &self,
        error: &E,
        config: &ErrorReportConfig,
        writer: &mut W,
    ) -> io::Result<()>
    where
        W: Write,
        E: std::error::Error,
    {
        // Implementation of plain text error reporting
        // This would use the Display or Debug implementations for errors
        // and format according to the config options
        writeln!(writer, "Error: {}", error)?;

        // If error supports source(), we can get the cause chain
        if config.include_source_chain {
            let mut source = error.source();
            let mut depth = 0;

            while let Some(err) = source {
                if let Some(max_depth) = config.max_chain_depth {
                    if depth >= max_depth {
                        writeln!(writer, "... (more causes hidden)")?;
                        break;
                    }
                }

                writeln!(writer, "Caused by: {}", err)?;
                source = err.source();
                depth += 1;
            }
        }

        // If the error has backtrace support (via ErrorCompat trait)
        // we would include it here
        if config.include_backtrace {
            // Placeholder for backtrace implementation
            // This would be implemented based on how your errors provide backtrace information
        }

        Ok(())
    }

    fn report_json<W, E>(
        &self,
        error: &E,
        config: &ErrorReportConfig,
        writer: &mut W,
    ) -> io::Result<()>
    where
        W: Write,
        E: std::error::Error,
    {
        // Implementation of JSON error reporting
        let mut json = String::from("{");

        // Add the main error message
        json.push_str(&format!(
            "\"error\": \"{}\"",
            error.to_string().replace("\"", "\\\"")
        ));

        // Add source chain if configured
        if config.include_source_chain {
            json.push_str(", \"causes\": [");
            let mut source = error.source();
            let mut is_first = true;
            let mut depth = 0;

            while let Some(err) = source {
                if let Some(max_depth) = config.max_chain_depth {
                    if depth >= max_depth {
                        break;
                    }
                }

                if !is_first {
                    json.push_str(", ");
                }
                json.push_str(&format!("\"{}\"", err.to_string().replace("\"", "\\\"")));

                source = err.source();
                is_first = false;
                depth += 1;
            }
            json.push_str("]");
        }

        json.push_str("}");

        // Pretty print if configured
        if config.pretty_print_json {
            // This is a very simple pretty print - a real implementation would use a JSON library
            json = json
                .replace("{", "{\n  ")
                .replace("}", "\n}")
                .replace(", ", ",\n  ");
        }

        writeln!(writer, "{}", json)?;
        Ok(())
    }

    fn report_markdown<W, E>(
        &self,
        error: &E,
        config: &ErrorReportConfig,
        writer: &mut W,
    ) -> io::Result<()>
    where
        W: Write,
        E: std::error::Error,
    {
        // Implementation of Markdown error reporting
        writeln!(writer, "## Error\n\n```")?;
        writeln!(writer, "{}", error)?;
        writeln!(writer, "```")?;

        // Add source chain if configured
        if config.include_source_chain {
            writeln!(writer, "\n### Causes\n")?;
            let mut source = error.source();
            let mut depth = 0;

            while let Some(err) = source {
                if let Some(max_depth) = config.max_chain_depth {
                    if depth >= max_depth {
                        writeln!(writer, "... (more causes hidden)")?;
                        break;
                    }
                }

                writeln!(writer, "- {}", err)?;
                source = err.source();
                depth += 1;
            }
        }

        Ok(())
    }

    fn report_html<W, E>(
        &self,
        error: &E,
        config: &ErrorReportConfig,
        writer: &mut W,
    ) -> io::Result<()>
    where
        W: Write,
        E: std::error::Error,
    {
        // Implementation of HTML error reporting
        writeln!(writer, "<div class=\"error\">")?;
        writeln!(writer, "  <h3>Error</h3>")?;
        writeln!(
            writer,
            "  <pre>{}</pre>",
            error.to_string().replace("<", "&lt;").replace(">", "&gt;")
        )?;

        // Add source chain if configured
        if config.include_source_chain {
            writeln!(writer, "  <h4>Causes</h4>")?;
            writeln!(writer, "  <ul>")?;

            let mut source = error.source();
            let mut depth = 0;

            while let Some(err) = source {
                if let Some(max_depth) = config.max_chain_depth {
                    if depth >= max_depth {
                        writeln!(writer, "    <li>... (more causes hidden)</li>")?;
                        break;
                    }
                }

                writeln!(
                    writer,
                    "    <li>{}</li>",
                    err.to_string().replace("<", "&lt;").replace(">", "&gt;")
                )?;

                source = err.source();
                depth += 1;
            }

            writeln!(writer, "  </ul>")?;
        }

        writeln!(writer, "</div>")?;
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::error::Error;
    use std::fmt;

    // Simple error type for testing
    #[derive(Debug)]
    struct TestError {
        message: String,
        source: Option<Box<dyn Error + Send + Sync>>,
    }

    impl fmt::Display for TestError {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "{}", self.message)
        }
    }

    impl Error for TestError {
        fn source(&self) -> Option<&(dyn Error + 'static)> {
            self.source
                .as_ref()
                .map(|s| s.as_ref() as &(dyn Error + 'static))
        }
    }

    #[test]
    fn test_error_reporter_plain_format() {
        // Create a test error
        let error = TestError {
            message: "Test error message".to_string(),
            source: None,
        };

        // Create reporter and config
        let reporter = ErrorReporter::new();
        let config = ErrorReportConfig {
            include_message: true,
            include_source_chain: true,
            include_backtrace: false,
            include_rich_context: false,
            include_source_location: false,
            include_severity: false,
            format: ErrorReportFormat::Plain,
            max_chain_depth: None,
            pretty_print_json: false,
            include_diagnostics: false,
        };

        // Generate report as string
        let report = reporter.report_to_string(&error, &config);

        // Verify report contains error message
        assert!(report.contains("Test error message"));
    }

    #[test]
    fn test_error_reporter_with_source() {
        // Create a nested error
        let source_error = TestError {
            message: "Source error".to_string(),
            source: None,
        };

        let error = TestError {
            message: "Main error".to_string(),
            source: Some(Box::new(source_error)),
        };

        // Create reporter and config
        let reporter = ErrorReporter::new();
        let config = ErrorReportConfig {
            include_message: true,
            include_source_chain: true,
            include_backtrace: false,
            include_rich_context: false,
            include_source_location: false,
            include_severity: false,
            format: ErrorReportFormat::Plain,
            max_chain_depth: None,
            pretty_print_json: false,
            include_diagnostics: false,
        };

        // Generate report as string
        let report = reporter.report_to_string(&error, &config);

        // Verify report contains both error messages
        assert!(report.contains("Main error"));
        assert!(report.contains("Source error"));
    }

    #[test]
    fn test_error_reporter_json_format() {
        // Create a test error
        let error = TestError {
            message: "JSON test error".to_string(),
            source: None,
        };

        // Create reporter and config
        let reporter = ErrorReporter::new();
        let config = ErrorReportConfig {
            format: ErrorReportFormat::Json,
            ..Default::default()
        };

        // Generate report as string
        let report = reporter.report_to_string(&error, &config);

        // Verify report is JSON formatted
        assert!(report.starts_with("{"));
        assert!(report.ends_with("}\n") || report.ends_with("}"));
        assert!(report.contains("\"error\""));
        assert!(report.contains("JSON test error"));
    }

    #[test]
    fn test_error_reporter_with_syntax() {
        // Create a test error
        let error = TestError {
            message: "Syntax error in code".to_string(),
            source: None,
        };

        // Sample source code
        let source_code = r#"
fn main() {
    let x: i32 = "not an integer"; // Type mismatch error
    println!("Value: {}", x);
}
"#;

        // Create reporter and config
        let reporter = ErrorReporter::new();
        let config = ErrorReportConfig {
            format: ErrorReportFormat::Markdown,
            ..Default::default()
        };

        // Generate report as string with syntax highlighting
        let report = reporter.report_to_string_with_syntax(&error, &config, Some(source_code));

        // Verify report contains both error message and source code
        assert!(report.contains("Syntax error in code"));
        assert!(report.contains("Source Code Context"));
        assert!(report.contains("```rust"));
        assert!(report.contains("let x: i32 = \"not an integer\";"));
    }
}



File: src.txt
=============



File: circuit_breaker.rs
========================
/* src/common/error/circuit_breaker.rs */
#![warn(missing_docs)]
//! **Brief:** Circuit breaker implementation for resilience.
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
//! + [Error Handling Framework]
//!  - [Circuit Breaker Pattern]
//!  - [Fault Tolerance]
//!  - [Service Resilience]
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
// **GitHub:** [ArcMoon Studios](https://github.com/arcmoonstudios)
// **Copyright:** (c) 2025 ArcMoon Studios
// **Author:** Lord Xyn
// **License:** MIT

//! This module provides a CircuitBreaker struct that helps protect the system
//! from cascading failures when interacting with external services or performing
//! operations prone to repeated errors.

use super::backtrace::DecrustBacktrace as Backtrace;
use super::{DecrustError, Result};
use std::collections::VecDeque;
use std::fmt;
use std::sync::{Arc, Mutex, RwLock};
use std::time::{Duration, Instant, SystemTime};
use tracing::info;

/// A wrapper for types that don't implement Debug
pub struct DebugIgnore<T: ?Sized>(pub T);

impl<T: ?Sized> fmt::Debug for DebugIgnore<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "<function>")
    }
}

impl<T: Clone + ?Sized> Clone for DebugIgnore<T> {
    fn clone(&self) -> Self {
        DebugIgnore(self.0.clone())
    }
}

#[cfg(feature = "rand")]
#[allow(unused_imports)]
use rand::Rng;
#[cfg(feature = "tokio")]
use tokio::time;

/// Represents the state of the circuit breaker.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum CircuitBreakerState {
    /// The circuit is closed, operations are allowed.
    Closed,
    /// The circuit is open, operations are rejected immediately.
    Open,
    /// The circuit is partially open, allowing a limited number of test operations.
    HalfOpen,
}

impl Default for CircuitBreakerState {
    fn default() -> Self {
        CircuitBreakerState::Closed
    }
}

impl fmt::Display for CircuitBreakerState {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

/// Type of operation outcome.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum CircuitOperationType {
    /// Operation completed successfully
    Success,
    /// Operation failed with an error
    Failure,
    /// Operation was rejected by the circuit breaker (e.g., when Open or HalfOpen limit reached)
    Rejected,
    /// Operation timed out
    Timeout,
}

/// Represents an event of state transition
#[derive(Debug, Clone)]
pub struct CircuitTransitionEvent {
    /// The state the circuit breaker is transitioning from
    pub from_state: CircuitBreakerState,
    /// The state the circuit breaker is transitioning to
    pub to_state: CircuitBreakerState,
    /// When the transition occurred
    pub timestamp: SystemTime,
    /// The reason for the state transition
    pub reason: String,
}

/// Observer trait for circuit breaker events.
///
/// Implement this trait to react to state changes, operation results,
/// and other significant events from the circuit breaker.
pub trait CircuitBreakerObserver: Send + Sync {
    /// Called when the circuit breaker's state changes.
    fn on_state_change(&self, name: &str, event: &CircuitTransitionEvent);
    /// Called before an operation is attempted (if not rejected immediately).
    fn on_operation_attempt(&self, name: &str, state: CircuitBreakerState);
    /// Called after an operation completes or is rejected/timed out.
    fn on_operation_result(
        &self,
        name: &str,
        op_type: CircuitOperationType,
        duration: Duration,
        error: Option<&DecrustError>,
    );
    /// Called when the circuit breaker is manually reset.
    fn on_reset(&self, name: &str);
}

/// Metrics collected by the circuit breaker
#[derive(Debug, Clone, Default)]
pub struct CircuitMetrics {
    /// Current state of the circuit breaker
    pub state: CircuitBreakerState,
    /// Total number of requests processed by the circuit breaker
    pub total_requests: u64,
    /// Number of successful requests
    pub successful_requests: u64,
    /// Number of failed requests
    pub failed_requests: u64,
    /// Number of requests rejected due to circuit breaker being open
    pub rejected_requests: u64,
    /// Number of requests that timed out
    pub timeout_requests: u64,
    /// Current count of consecutive failures
    pub consecutive_failures: u32,
    /// Current count of consecutive successes
    pub consecutive_successes: u32,
    /// Timestamp of the last error that occurred
    pub last_error_timestamp: Option<SystemTime>,
    /// Timestamp of the last state transition
    pub last_transition_timestamp: Option<SystemTime>,
    /// Current failure rate calculated over the sliding window (0.0 to 1.0)
    pub failure_rate_in_window: Option<f64>,
    /// Current rate of slow calls calculated over the sliding window (0.0 to 1.0)
    pub slow_call_rate_in_window: Option<f64>,
}

/// Configuration for the CircuitBreaker.
///
/// Defines thresholds and timeouts that control the behavior of the circuit breaker.
#[derive(Clone)]
pub struct CircuitBreakerConfig {
    /// The number of consecutive failures after which the circuit opens.
    pub failure_threshold: usize,
    /// The failure rate (0.0 to 1.0) within the sliding window that causes the circuit to open.
    pub failure_rate_threshold: f64,
    /// The minimum number of requests in the sliding window before the failure rate is considered.
    pub minimum_request_threshold_for_rate: usize,
    /// The number of consecutive successes required in HalfOpen state to transition to Closed.
    pub success_threshold_to_close: usize,
    /// The duration the circuit stays Open before transitioning to HalfOpen.
    pub reset_timeout: Duration,
    /// The maximum number of operations allowed to execute concurrently when in HalfOpen state.
    pub half_open_max_concurrent_operations: usize,
    /// Optional timeout for individual operations executed through the circuit breaker.
    pub operation_timeout: Option<Duration>,
    /// The size of the sliding window used for calculating failure rates.
    pub sliding_window_size: usize,
    /// An optional predicate to determine if a specific `DecrustError` should be considered a failure.
    /// If `None`, all `Err` results are considered failures.
    pub error_predicate: Option<Arc<dyn Fn(&DecrustError) -> bool + Send + Sync>>,
    /// The size of the history window for detailed metrics (not fully implemented in this version).
    pub metrics_window_size: usize, // Currently used for result_window and slow_call_window size logic
    /// Whether to track detailed metrics.
    pub track_metrics: bool,
    /// Threshold for an operation to be considered a "slow call".
    pub slow_call_duration_threshold: Option<Duration>,
    /// Rate of slow calls (0.0 to 1.0) in the window that can cause the circuit to open.
    pub slow_call_rate_threshold: Option<f64>,
    /// Number of consecutive failures before opening the circuit breaker.
    pub circuit_breaker_threshold: u32,
    /// Duration the circuit breaker stays open after tripping.
    pub circuit_breaker_cooldown: Duration,
}

impl Default for CircuitBreakerConfig {
    fn default() -> Self {
        Self {
            failure_threshold: 5,
            failure_rate_threshold: 0.5,
            minimum_request_threshold_for_rate: 10,
            success_threshold_to_close: 3,
            reset_timeout: Duration::from_secs(30),
            half_open_max_concurrent_operations: 1,
            operation_timeout: Some(Duration::from_secs(5)),
            sliding_window_size: 100,
            error_predicate: None,
            metrics_window_size: 100, // This could influence window sizes if not for fixed `sliding_window_size`
            track_metrics: true,
            slow_call_duration_threshold: None, // e.g., Some(Duration::from_millis(500))
            slow_call_rate_threshold: None,     // e.g., Some(0.3) for 30% slow calls
            circuit_breaker_threshold: 3,       // Default to 3 consecutive failures
            circuit_breaker_cooldown: Duration::from_secs(60), // Default to 60 seconds cooldown
        }
    }
}

impl fmt::Debug for CircuitBreakerConfig {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("CircuitBreakerConfig")
            .field("failure_threshold", &self.failure_threshold)
            .field("failure_rate_threshold", &self.failure_rate_threshold)
            .field(
                "minimum_request_threshold_for_rate",
                &self.minimum_request_threshold_for_rate,
            )
            .field(
                "success_threshold_to_close",
                &self.success_threshold_to_close,
            )
            .field("reset_timeout", &self.reset_timeout)
            .field(
                "half_open_max_concurrent_operations",
                &self.half_open_max_concurrent_operations,
            )
            .field("operation_timeout", &self.operation_timeout)
            .field("sliding_window_size", &self.sliding_window_size)
            .field(
                "error_predicate",
                &if self.error_predicate.is_some() {
                    "Some(<function>)"
                } else {
                    "None"
                },
            )
            .field("metrics_window_size", &self.metrics_window_size)
            .field("track_metrics", &self.track_metrics)
            .field(
                "slow_call_duration_threshold",
                &self.slow_call_duration_threshold,
            )
            .field("slow_call_rate_threshold", &self.slow_call_rate_threshold)
            .field("circuit_breaker_threshold", &self.circuit_breaker_threshold)
            .field("circuit_breaker_cooldown", &self.circuit_breaker_cooldown)
            .finish()
    }
}

#[derive(Debug)] // Added Debug derive for InnerState
struct InnerState {
    state: CircuitBreakerState,
    opened_at: Option<Instant>,
    half_open_entered_at: Option<Instant>,
    consecutive_failures: usize,
    consecutive_successes: usize,
    half_open_concurrency_count: usize,
    results_window: VecDeque<bool>, // true for success, false for failure
    slow_call_window: VecDeque<bool>, // true if call was slow
    metrics: CircuitMetrics,
}

impl Default for InnerState {
    fn default() -> Self {
        Self {
            state: CircuitBreakerState::Closed,
            opened_at: None,
            half_open_entered_at: None,
            consecutive_failures: 0,
            consecutive_successes: 0,
            half_open_concurrency_count: 0,
            results_window: VecDeque::with_capacity(100),
            slow_call_window: VecDeque::with_capacity(100),
            metrics: CircuitMetrics::default(),
        }
    }
}

/// A circuit breaker implementation to prevent cascading failures.
pub struct CircuitBreaker {
    name: String,
    config: CircuitBreakerConfig,
    inner: RwLock<InnerState>,
    observers: Mutex<Vec<Arc<dyn CircuitBreakerObserver>>>,
}

impl CircuitBreaker {
    /// Creates a new CircuitBreaker instance
    pub fn new(name: impl Into<String>, config: CircuitBreakerConfig) -> Arc<Self> {
        Arc::new(Self {
            name: name.into(),
            config,
            inner: RwLock::new(InnerState::default()),
            observers: Mutex::new(Vec::new()),
        })
    }

    /// Add an observer to the circuit breaker
    pub fn add_observer(&self, observer: Arc<dyn CircuitBreakerObserver>) {
        let mut observers = self.observers.lock().unwrap();
        observers.push(observer);
    }

    /// Get the current state of the circuit breaker
    pub fn state(&self) -> CircuitBreakerState {
        let inner = self.inner.read().unwrap();
        inner.state
    }

    /// Get the current metrics of the circuit breaker
    pub fn metrics(&self) -> CircuitMetrics {
        let inner = self.inner.read().unwrap();
        inner.metrics.clone()
    }

    /// Trip the circuit breaker manually
    pub fn trip(&self) {
        let mut inner = self.inner.write().unwrap();
        let prev_state = inner.state;
        inner.state = CircuitBreakerState::Open;
        inner.opened_at = Some(Instant::now());
        inner.consecutive_failures = self.config.failure_threshold;
        inner.consecutive_successes = 0;

        let event = CircuitTransitionEvent {
            from_state: prev_state,
            to_state: CircuitBreakerState::Open,
            timestamp: SystemTime::now(),
            reason: "Manual trip".to_string(),
        };

        // Update metrics
        inner.metrics.state = CircuitBreakerState::Open;
        inner.metrics.consecutive_failures = inner.consecutive_failures as u32;
        inner.metrics.consecutive_successes = 0;
        inner.metrics.last_transition_timestamp = Some(SystemTime::now());

        // Drop the lock before calling observers
        drop(inner);

        // Notify observers
        self.notify_state_change(&event);
    }

    /// Reset the circuit breaker to closed state
    pub fn reset(&self) {
        let mut inner = self.inner.write().unwrap();
        let prev_state = inner.state;
        inner.state = CircuitBreakerState::Closed;
        inner.opened_at = None;
        inner.half_open_entered_at = None;
        inner.consecutive_failures = 0;
        inner.consecutive_successes = 0;
        inner.half_open_concurrency_count = 0;

        // Update metrics
        inner.metrics.state = CircuitBreakerState::Closed;
        inner.metrics.consecutive_failures = 0;
        inner.metrics.consecutive_successes = 0;
        inner.metrics.last_transition_timestamp = Some(SystemTime::now());

        // Clear windows
        inner.results_window.clear();
        inner.slow_call_window.clear();

        let event = CircuitTransitionEvent {
            from_state: prev_state,
            to_state: CircuitBreakerState::Closed,
            timestamp: SystemTime::now(),
            reason: "Manual reset".to_string(),
        };

        // Drop the lock before calling observers
        drop(inner);

        // Notify observers
        self.notify_state_change(&event);
        self.notify_reset();
    }

    /// Execute an operation through the circuit breaker
    pub fn execute<F, Ret>(&self, operation: F) -> Result<Ret>
    where
        F: FnOnce() -> Result<Ret>,
    {
        let start_time = Instant::now();
        let state = self.state();

        self.notify_operation_attempt(state);

        match state {
            CircuitBreakerState::Open => {
                // Check if reset timeout has elapsed
                let inner = self.inner.read().unwrap();
                let should_transition = if let Some(opened_at) = inner.opened_at {
                    opened_at.elapsed() >= self.config.reset_timeout
                } else {
                    false
                };
                drop(inner);

                if should_transition {
                    self.transition_to_half_open("Reset timeout elapsed");
                    // Continue with half-open logic
                    self.execute_half_open(operation, start_time)
                } else {
                    // Still open, reject the operation
                    self.record_rejected();
                    Err(DecrustError::CircuitBreakerOpen {
                        name: self.name.clone(),
                        retry_after: Some(
                            self.config
                                .reset_timeout
                                .checked_sub(
                                    self.inner.read().unwrap().opened_at.unwrap().elapsed(),
                                )
                                .unwrap_or_default(),
                        ),
                        backtrace: Backtrace::generate(),
                    })
                }
            }
            CircuitBreakerState::HalfOpen => self.execute_half_open(operation, start_time),
            CircuitBreakerState::Closed => self.execute_closed(operation, start_time),
        }
    }

    /// Execute an async operation through the circuit breaker
    #[cfg(feature = "tokio")]
    pub async fn execute_async<F, Fut, Ret>(&self, operation: F) -> Result<Ret>
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = Result<Ret>>,
    {
        let start_time = Instant::now();
        let state = self.state();

        self.notify_operation_attempt(state);

        match state {
            CircuitBreakerState::Open => {
                // Check if reset timeout has elapsed
                let inner = self.inner.read().unwrap();
                let should_transition = if let Some(opened_at) = inner.opened_at {
                    opened_at.elapsed() >= self.config.reset_timeout
                } else {
                    false
                };
                drop(inner);

                if should_transition {
                    self.transition_to_half_open("Reset timeout elapsed");
                    // Continue with half-open logic
                    self.execute_half_open_async(operation, start_time).await
                } else {
                    // Still open, reject the operation
                    self.record_rejected();
                    Err(DecrustError::CircuitBreakerOpen {
                        name: self.name.clone(),
                        retry_after: Some(
                            self.config
                                .reset_timeout
                                .checked_sub(
                                    self.inner.read().unwrap().opened_at.unwrap().elapsed(),
                                )
                                .unwrap_or_default(),
                        ),
                        backtrace: Backtrace::generate(),
                    })
                }
            }
            CircuitBreakerState::HalfOpen => {
                self.execute_half_open_async(operation, start_time).await
            }
            CircuitBreakerState::Closed => self.execute_closed_async(operation, start_time).await,
        }
    }

    // Private helper methods

    // Execute operation in Closed state
    fn execute_closed<F, Ret>(&self, operation: F, start_time: Instant) -> Result<Ret>
    where
        F: FnOnce() -> Result<Ret>,
    {
        let result = if let Some(timeout) = self.config.operation_timeout {
            self.execute_with_timeout(operation, timeout)
        } else {
            operation()
        };

        let duration = start_time.elapsed();

        match &result {
            Ok(_) => {
                self.record_success(duration);
            }
            Err(e) => {
                if self.should_count_as_failure(e) {
                    self.record_failure(e, duration);

                    // Check if we need to open the circuit
                    if self.should_open_circuit() {
                        self.transition_to_open("Failure threshold reached");
                    }
                } else {
                    // Error not counted as failure for circuit breaking
                    self.record_success(duration);
                }
            }
        }

        result
    }

    // Execute operation in HalfOpen state
    fn execute_half_open<F, Ret>(&self, operation: F, start_time: Instant) -> Result<Ret>
    where
        F: FnOnce() -> Result<Ret>,
    {
        // Check if we can proceed with the operation
        {
            let mut inner = self.inner.write().unwrap();
            if inner.half_open_concurrency_count >= self.config.half_open_max_concurrent_operations
            {
                // Too many concurrent operations in half-open state
                self.record_rejected();
                return Err(DecrustError::CircuitBreakerOpen {
                    name: self.name.clone(),
                    retry_after: Some(Duration::from_millis(100)),
                    backtrace: Backtrace::generate(),
                });
            }

            // Increment concurrency count
            inner.half_open_concurrency_count += 1;
        }

        // Execute the operation
        let result = if let Some(timeout) = self.config.operation_timeout {
            self.execute_with_timeout(operation, timeout)
        } else {
            operation()
        };

        let duration = start_time.elapsed();

        // Decrement concurrency count
        {
            let mut inner = self.inner.write().unwrap();
            inner.half_open_concurrency_count = inner.half_open_concurrency_count.saturating_sub(1);
        }

        match &result {
            Ok(_) => {
                self.record_success(duration);

                // Check if we can close the circuit
                let close_circuit = {
                    let inner = self.inner.read().unwrap();
                    inner.consecutive_successes >= self.config.success_threshold_to_close
                };

                if close_circuit {
                    self.transition_to_closed("Success threshold reached");
                }
            }
            Err(e) => {
                if self.should_count_as_failure(e) {
                    self.record_failure(e, duration);

                    // Any failure in half-open should open the circuit again
                    self.transition_to_open("Failure in half-open state");
                } else {
                    // Error not counted as failure for circuit breaking
                    self.record_success(duration);
                }
            }
        }

        result
    }

    // Async versions

    #[cfg(feature = "tokio")]
    async fn execute_closed_async<F, Fut, Ret>(
        &self,
        operation: F,
        start_time: Instant,
    ) -> Result<Ret>
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = Result<Ret>>,
    {
        let result = if let Some(timeout) = self.config.operation_timeout {
            self.execute_with_timeout_async(operation, timeout).await
        } else {
            operation().await
        };

        let duration = start_time.elapsed();

        match &result {
            Ok(_) => {
                self.record_success(duration);
            }
            Err(e) => {
                if self.should_count_as_failure(e) {
                    self.record_failure(e, duration);

                    // Check if we need to open the circuit
                    if self.should_open_circuit() {
                        self.transition_to_open("Failure threshold reached");
                    }
                } else {
                    // Error not counted as failure for circuit breaking
                    self.record_success(duration);
                }
            }
        }

        result
    }

    #[cfg(feature = "tokio")]
    async fn execute_half_open_async<F, Fut, Ret>(
        &self,
        operation: F,
        start_time: Instant,
    ) -> Result<Ret>
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = Result<Ret>>,
    {
        // Check if we can proceed with the operation
        {
            let mut inner = self.inner.write().unwrap();
            if inner.half_open_concurrency_count >= self.config.half_open_max_concurrent_operations
            {
                // Too many concurrent operations in half-open state
                self.record_rejected();
                return Err(DecrustError::CircuitBreakerOpen {
                    name: self.name.clone(),
                    retry_after: Some(Duration::from_millis(100)),
                    backtrace: Backtrace::generate(),
                });
            }

            // Increment concurrency count
            inner.half_open_concurrency_count += 1;
        }

        // Execute the operation
        let result = if let Some(timeout) = self.config.operation_timeout {
            self.execute_with_timeout_async(operation, timeout).await
        } else {
            operation().await
        };

        let duration = start_time.elapsed();

        // Decrement concurrency count
        {
            let mut inner = self.inner.write().unwrap();
            inner.half_open_concurrency_count = inner.half_open_concurrency_count.saturating_sub(1);
        }

        match &result {
            Ok(_) => {
                self.record_success(duration);

                // Check if we can close the circuit
                let close_circuit = {
                    let inner = self.inner.read().unwrap();
                    inner.consecutive_successes >= self.config.success_threshold_to_close
                };

                if close_circuit {
                    self.transition_to_closed("Success threshold reached");
                }
            }
            Err(e) => {
                if self.should_count_as_failure(e) {
                    self.record_failure(e, duration);

                    // Any failure in half-open should open the circuit again
                    self.transition_to_open("Failure in half-open state");
                } else {
                    // Error not counted as failure for circuit breaking
                    self.record_success(duration);
                }
            }
        }

        result
    }

    // Timeout helpers

    fn execute_with_timeout<F, Ret>(&self, operation: F, timeout: Duration) -> Result<Ret>
    where
        F: FnOnce() -> Result<Ret>,
    {
        // Simple timeout implementation for non-async code
        // In a real implementation, you'd likely want to use a more sophisticated approach

        #[cfg(not(feature = "std-thread"))]
        {
            // Fallback implementation without threads
            let start = Instant::now();
            let result = operation();
            if start.elapsed() > timeout {
                self.record_timeout();
                Err(DecrustError::Timeout {
                    operation: format!("Operation in circuit breaker '{}'", self.name),
                    duration: timeout,
                    backtrace: Backtrace::generate(),
                })
            } else {
                result
            }
        }

        #[cfg(feature = "std-thread")]
        {
            use std::sync::mpsc;
            use std::thread;

            let (tx, rx) = mpsc::channel();

            let handle = thread::spawn(move || {
                let result = operation();
                let _ = tx.send(result);
            });

            match rx.recv_timeout(timeout) {
                Ok(result) => {
                    // Operation completed within timeout
                    let _ = handle.join();
                    result
                }
                Err(_) => {
                    // Operation timed out
                    self.record_timeout();
                    Err(DecrustError::Timeout {
                        operation: format!("Operation in circuit breaker '{}'", self.name),
                        duration: timeout,
                        backtrace: Backtrace::generate(),
                    })
                }
            }
        }
    }

    #[cfg(feature = "tokio")]
    async fn execute_with_timeout_async<F, Fut, Ret>(
        &self,
        operation: F,
        timeout: Duration,
    ) -> Result<Ret>
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = Result<Ret>>,
    {
        match time::timeout(timeout, operation()).await {
            Ok(result) => result,
            Err(_) => {
                self.record_timeout();
                Err(DecrustError::Timeout {
                    operation: format!("Operation in circuit breaker '{}'", self.name),
                    duration: timeout,
                    backtrace: Backtrace::generate(),
                })
            }
        }
    }

    // State transition helpers

    fn transition_to_open(&self, reason: &str) {
        let mut inner = self.inner.write().unwrap();
        let prev_state = inner.state;
        inner.state = CircuitBreakerState::Open;
        inner.opened_at = Some(Instant::now());
        inner.consecutive_successes = 0;

        let event = CircuitTransitionEvent {
            from_state: prev_state,
            to_state: CircuitBreakerState::Open,
            timestamp: SystemTime::now(),
            reason: reason.to_string(),
        };

        // Update metrics
        inner.metrics.state = CircuitBreakerState::Open;
        inner.metrics.last_transition_timestamp = Some(SystemTime::now());

        // Drop the lock before calling observers
        drop(inner);

        info!(
            "Circuit breaker '{}' transitioning to Open: {}",
            self.name, reason
        );
        self.notify_state_change(&event);
    }

    fn transition_to_half_open(&self, reason: &str) {
        let mut inner = self.inner.write().unwrap();
        let prev_state = inner.state;
        inner.state = CircuitBreakerState::HalfOpen;
        inner.half_open_entered_at = Some(Instant::now());
        inner.consecutive_successes = 0;
        inner.half_open_concurrency_count = 0;

        let event = CircuitTransitionEvent {
            from_state: prev_state,
            to_state: CircuitBreakerState::HalfOpen,
            timestamp: SystemTime::now(),
            reason: reason.to_string(),
        };

        // Update metrics
        inner.metrics.state = CircuitBreakerState::HalfOpen;
        inner.metrics.last_transition_timestamp = Some(SystemTime::now());

        // Drop the lock before calling observers
        drop(inner);

        info!(
            "Circuit breaker '{}' transitioning to HalfOpen: {}",
            self.name, reason
        );
        self.notify_state_change(&event);
    }

    fn transition_to_closed(&self, reason: &str) {
        let mut inner = self.inner.write().unwrap();
        let prev_state = inner.state;
        inner.state = CircuitBreakerState::Closed;
        inner.opened_at = None;
        inner.half_open_entered_at = None;
        inner.consecutive_failures = 0;

        let event = CircuitTransitionEvent {
            from_state: prev_state,
            to_state: CircuitBreakerState::Closed,
            timestamp: SystemTime::now(),
            reason: reason.to_string(),
        };

        // Update metrics
        inner.metrics.state = CircuitBreakerState::Closed;
        inner.metrics.last_transition_timestamp = Some(SystemTime::now());

        // Drop the lock before calling observers
        drop(inner);

        info!(
            "Circuit breaker '{}' transitioning to Closed: {}",
            self.name, reason
        );
        self.notify_state_change(&event);
    }

    // Result recording helpers

    fn record_success(&self, duration: Duration) {
        let mut inner = self.inner.write().unwrap();
        inner.consecutive_successes += 1;
        inner.consecutive_failures = 0;

        // Update sliding window
        if inner.results_window.len() >= self.config.sliding_window_size {
            inner.results_window.pop_front();
        }
        inner.results_window.push_back(true);

        // Check if the call was slow
        let was_slow = if let Some(threshold) = self.config.slow_call_duration_threshold {
            duration >= threshold
        } else {
            false
        };

        // Update slow call window
        if inner.slow_call_window.len() >= self.config.sliding_window_size {
            inner.slow_call_window.pop_front();
        }
        inner.slow_call_window.push_back(was_slow);

        // Update metrics
        inner.metrics.total_requests += 1;
        inner.metrics.successful_requests += 1;
        inner.metrics.consecutive_successes = inner.consecutive_successes as u32;
        inner.metrics.consecutive_failures = 0;

        // Calculate rates
        self.update_rates(&mut inner);

        drop(inner);

        self.notify_operation_result(CircuitOperationType::Success, duration, None);
    }

    fn record_failure(&self, error: &DecrustError, duration: Duration) {
        let mut inner = self.inner.write().unwrap();
        inner.consecutive_failures += 1;
        inner.consecutive_successes = 0;

        // Update sliding window
        if inner.results_window.len() >= self.config.sliding_window_size {
            inner.results_window.pop_front();
        }
        inner.results_window.push_back(false);

        // Check if the call was slow (although it failed)
        let was_slow = if let Some(threshold) = self.config.slow_call_duration_threshold {
            duration >= threshold
        } else {
            false
        };

        // Update slow call window
        if inner.slow_call_window.len() >= self.config.sliding_window_size {
            inner.slow_call_window.pop_front();
        }
        inner.slow_call_window.push_back(was_slow);

        // Update metrics
        inner.metrics.total_requests += 1;
        inner.metrics.failed_requests += 1;
        inner.metrics.consecutive_failures = inner.consecutive_failures as u32;
        inner.metrics.consecutive_successes = 0;
        inner.metrics.last_error_timestamp = Some(SystemTime::now());

        // Calculate rates
        self.update_rates(&mut inner);

        let error_clone = error.clone(); // This requires Clone for DecrustError
        drop(inner);

        self.notify_operation_result(CircuitOperationType::Failure, duration, Some(&error_clone));
    }

    fn record_rejected(&self) {
        let mut inner = self.inner.write().unwrap();
        inner.metrics.total_requests += 1;
        inner.metrics.rejected_requests += 1;
        drop(inner);

        // Zero duration since operation was rejected
        self.notify_operation_result(CircuitOperationType::Rejected, Duration::from_secs(0), None);
    }

    fn record_timeout(&self) {
        let mut inner = self.inner.write().unwrap();
        inner.consecutive_failures += 1;
        inner.consecutive_successes = 0;

        // Update sliding window
        if inner.results_window.len() >= self.config.sliding_window_size {
            inner.results_window.pop_front();
        }
        inner.results_window.push_back(false);

        // Update metrics
        inner.metrics.total_requests += 1;
        inner.metrics.timeout_requests += 1;
        inner.metrics.consecutive_failures = inner.consecutive_failures as u32;
        inner.metrics.consecutive_successes = 0;
        inner.metrics.last_error_timestamp = Some(SystemTime::now());

        // Calculate rates
        self.update_rates(&mut inner);

        drop(inner);

        let timeout_error = DecrustError::Timeout {
            operation: format!("Operation in circuit breaker '{}'", self.name),
            duration: self.config.operation_timeout.unwrap_or_default(),
            backtrace: Backtrace::generate(),
        };

        self.notify_operation_result(
            CircuitOperationType::Timeout,
            self.config.operation_timeout.unwrap_or_default(),
            Some(&timeout_error),
        );
    }

    // Helper methods

    fn should_open_circuit(&self) -> bool {
        let inner = self.inner.read().unwrap();

        // Open if consecutive failures exceed threshold
        if inner.consecutive_failures >= self.config.failure_threshold {
            return true;
        }

        // Check failure rate if we have enough samples
        if inner.results_window.len() >= self.config.minimum_request_threshold_for_rate {
            let failure_count = inner
                .results_window
                .iter()
                .filter(|&&success| !success)
                .count();
            let failure_rate = failure_count as f64 / inner.results_window.len() as f64;

            if failure_rate >= self.config.failure_rate_threshold {
                return true;
            }
        }

        // Check slow call rate if configured
        if let (Some(threshold), true) = (
            self.config.slow_call_rate_threshold,
            !inner.slow_call_window.is_empty(),
        ) {
            let slow_count = inner.slow_call_window.iter().filter(|&&slow| slow).count();
            let slow_rate = slow_count as f64 / inner.slow_call_window.len() as f64;

            if slow_rate >= threshold {
                return true;
            }
        }

        false
    }

    fn should_count_as_failure(&self, error: &DecrustError) -> bool {
        // If there's a custom predicate, use that
        if let Some(predicate) = &self.config.error_predicate {
            return (predicate.as_ref())(error);
        }

        // By default, all errors count as failures
        true
    }

    fn update_rates(&self, inner: &mut InnerState) {
        if inner.results_window.is_empty() {
            inner.metrics.failure_rate_in_window = None;
        } else {
            let failure_count = inner
                .results_window
                .iter()
                .filter(|&&success| !success)
                .count();
            let failure_rate = failure_count as f64 / inner.results_window.len() as f64;
            inner.metrics.failure_rate_in_window = Some(failure_rate);
        }

        if inner.slow_call_window.is_empty() {
            inner.metrics.slow_call_rate_in_window = None;
        } else {
            let slow_count = inner.slow_call_window.iter().filter(|&&slow| slow).count();
            let slow_rate = slow_count as f64 / inner.slow_call_window.len() as f64;
            inner.metrics.slow_call_rate_in_window = Some(slow_rate);
        }
    }

    // Observer notification methods

    fn notify_state_change(&self, event: &CircuitTransitionEvent) {
        let observers = self.observers.lock().unwrap();
        for observer in &*observers {
            observer.on_state_change(&self.name, event);
        }
    }

    fn notify_operation_attempt(&self, state: CircuitBreakerState) {
        let observers = self.observers.lock().unwrap();
        for observer in &*observers {
            observer.on_operation_attempt(&self.name, state);
        }
    }

    fn notify_operation_result(
        &self,
        op_type: CircuitOperationType,
        duration: Duration,
        error: Option<&DecrustError>,
    ) {
        let observers = self.observers.lock().unwrap();
        for observer in &*observers {
            observer.on_operation_result(&self.name, op_type, duration, error);
        }
    }
    fn notify_reset(&self) {
        let observers = self.observers.lock().unwrap();
        for observer in &*observers {
            observer.on_reset(&self.name);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::super::OptionalError;
    use super::*;
    use crate::backtrace::DecrustBacktrace as Backtrace;
    use std::sync::atomic::{AtomicUsize, Ordering};

    // Mock observer for testing
    struct TestObserver {
        state_changes: AtomicUsize,
        operation_attempts: AtomicUsize,
        operation_results: AtomicUsize,
        resets: AtomicUsize,
    }

    impl TestObserver {
        fn new() -> Self {
            Self {
                state_changes: AtomicUsize::new(0),
                operation_attempts: AtomicUsize::new(0),
                operation_results: AtomicUsize::new(0),
                resets: AtomicUsize::new(0),
            }
        }
    }

    impl CircuitBreakerObserver for TestObserver {
        fn on_state_change(&self, _name: &str, _event: &CircuitTransitionEvent) {
            self.state_changes.fetch_add(1, Ordering::SeqCst);
        }

        fn on_operation_attempt(&self, _name: &str, _state: CircuitBreakerState) {
            self.operation_attempts.fetch_add(1, Ordering::SeqCst);
        }

        fn on_operation_result(
            &self,
            _name: &str,
            _op_type: CircuitOperationType,
            _duration: Duration,
            _error: Option<&DecrustError>,
        ) {
            self.operation_results.fetch_add(1, Ordering::SeqCst);
        }

        fn on_reset(&self, _name: &str) {
            self.resets.fetch_add(1, Ordering::SeqCst);
        }
    }

    #[test]
    fn test_circuit_breaker_initial_state() {
        let config = CircuitBreakerConfig::default();
        let cb = CircuitBreaker::new("test-circuit", config);

        assert_eq!(cb.state(), CircuitBreakerState::Closed);
    }

    #[test]
    fn test_circuit_breaker_trip() {
        let config = CircuitBreakerConfig::default();
        let cb = CircuitBreaker::new("test-circuit", config);

        // Initial state should be Closed
        assert_eq!(cb.state(), CircuitBreakerState::Closed);

        // Trip the circuit
        cb.trip();

        // State should now be Open
        assert_eq!(cb.state(), CircuitBreakerState::Open);

        // Reset the circuit
        cb.reset();

        // State should be Closed again
        assert_eq!(cb.state(), CircuitBreakerState::Closed);
    }

    #[test]
    fn test_circuit_breaker_observer_notifications() {
        let config = CircuitBreakerConfig::default();
        let cb = CircuitBreaker::new("test-circuit", config);
        let observer = Arc::new(TestObserver::new());

        // Add observer
        cb.add_observer(observer.clone());

        // Trip the circuit
        cb.trip();

        // Reset the circuit
        cb.reset();

        // Verify observer counts
        assert_eq!(observer.state_changes.load(Ordering::SeqCst), 2); // One for trip, one for reset
        assert_eq!(observer.resets.load(Ordering::SeqCst), 1);
    }

    #[test]
    fn test_circuit_breaker_execute_success() {
        let config = CircuitBreakerConfig::default();
        let cb = CircuitBreaker::new("test-circuit", config);

        // Execute successful operation
        let result: Result<i32, DecrustError> = cb.execute(|| Ok(42));

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 42);
    }

    #[test]
    fn test_circuit_breaker_default_state() {
        let cb = CircuitBreaker::new("test", CircuitBreakerConfig::default());
        assert_eq!(cb.state(), CircuitBreakerState::Closed);
    }

    #[test]
    fn test_circuit_breaker_execute_error() {
        let config = CircuitBreakerConfig::default();
        let cb = CircuitBreaker::new("test-circuit", config);

        // Execute operation that returns an error
        let result: Result<i32, DecrustError> = cb.execute(|| {
            Err(DecrustError::Internal {
                message: "Test error".to_string(),
                source: OptionalError::new(None),
                backtrace: Backtrace::generate(),
            })
        });

        assert!(result.is_err());
    }
}



File: syntax.rs
===============
/* src/common/error/syntax.rs */
#![warn(missing_docs)]
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
//! + [Syntax Generation Module]
//!  - [AST-Aware Code Generation]
//!  - [Template-Based Code Generation]
//!  - [Syntax Tree Manipulation]
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>

//! This module provides utilities for generating and manipulating Rust code
//! using the quote and syn crates. It enables AST-aware code generation for
//! the autocorrection system.

use super::types::ErrorCategory;
use std::collections::HashMap;

/// Template for generating code fixes
#[derive(Debug, Clone)]
pub struct FixTemplate {
    /// Name of the template
    pub name: String,
    /// Description of what the template does
    pub description: String,
    /// The template code with placeholders
    pub template: String,
    /// The error categories this template applies to
    pub applicable_categories: Vec<ErrorCategory>,
    /// The error codes this template targets
    pub target_error_codes: Vec<String>,
}

impl FixTemplate {
    /// Creates a new FixTemplate
    ///
    /// # Parameters
    /// * `name` - Name of the template
    /// * `description` - Description of what the template does
    /// * `template` - The template code with placeholders
    pub fn new(
        name: impl Into<String>,
        description: impl Into<String>,
        template: impl Into<String>,
    ) -> Self {
        Self {
            name: name.into(),
            description: description.into(),
            template: template.into(),
            applicable_categories: Vec::new(),
            target_error_codes: Vec::new(),
        }
    }

    /// Adds an applicable error category
    ///
    /// # Parameters
    /// * `category` - Error category this template applies to
    pub fn add_category(mut self, category: ErrorCategory) -> Self {
        self.applicable_categories.push(category);
        self
    }

    /// Adds a target error code
    ///
    /// # Parameters
    /// * `code` - Error code this template targets
    pub fn add_error_code(mut self, code: impl Into<String>) -> Self {
        self.target_error_codes.push(code.into());
        self
    }

    /// Applies the template with the given parameters
    ///
    /// # Parameters
    /// * `params` - Map of parameter names to values
    ///
    /// # Returns
    /// The template with placeholders replaced by parameter values
    pub fn apply(&self, params: &HashMap<String, String>) -> String {
        let mut result = self.template.clone();
        for (key, value) in params {
            result = result.replace(&format!("{{{}}}", key), value);
        }
        result
    }
}

/// Utility for generating syntax-aware code using the quote crate
#[derive(Debug, Default)]
pub struct SyntaxGenerator;

impl SyntaxGenerator {
    /// Creates a new SyntaxGenerator
    pub fn new() -> Self {
        Self
    }

    /// Generates a trait implementation for a type
    ///
    /// # Parameters
    /// * `trait_name` - Name of the trait to implement
    /// * `type_name` - Name of the type to implement the trait for
    /// * `methods` - Map of method names to method bodies
    ///
    /// # Returns
    /// Generated trait implementation as a string
    pub fn generate_trait_impl(
        &self,
        trait_name: &str,
        type_name: &str,
        methods: HashMap<String, String>,
    ) -> String {
        let mut impl_body = String::new();
        for (method_name, method_body) in methods {
            impl_body.push_str(&format!(
                "    fn {}() {{\n        {}\n    }}\n\n",
                method_name, method_body
            ));
        }

        format!(
            "impl {} for {} {{\n{}}}\n",
            trait_name, type_name, impl_body
        )
    }

    /// Generates an import statement
    ///
    /// # Parameters
    /// * `path` - Path to import
    /// * `items` - Items to import from the path
    ///
    /// # Returns
    /// Generated import statement as a string
    pub fn generate_import(&self, path: &str, items: &[&str]) -> String {
        if items.is_empty() {
            format!("use {};", path)
        } else if items.len() == 1 {
            format!("use {}::{};", path, items[0])
        } else {
            let items_str = items.join(", ");
            format!("use {}::{{{}}};", path, items_str)
        }
    }

    /// Generates a struct definition
    ///
    /// # Parameters
    /// * `struct_name` - Name of the struct
    /// * `fields` - Map of field names to field types
    /// * `derive_traits` - Optional list of traits to derive
    ///
    /// # Returns
    /// Generated struct definition as a string
    pub fn generate_struct(
        &self,
        struct_name: &str,
        fields: HashMap<String, String>,
        derive_traits: Option<Vec<&str>>,
    ) -> String {
        let mut struct_def = String::new();

        // Add derive attributes if provided
        if let Some(traits) = derive_traits {
            if !traits.is_empty() {
                struct_def.push_str(&format!("#[derive({})]\n", traits.join(", ")));
            }
        }

        struct_def.push_str(&format!("pub struct {} {{\n", struct_name));

        // Add fields
        for (field_name, field_type) in fields {
            struct_def.push_str(&format!("    pub {}: {},\n", field_name, field_type));
        }

        struct_def.push_str("}\n");
        struct_def
    }

    /// Generates an enum definition
    ///
    /// # Parameters
    /// * `enum_name` - Name of the enum
    /// * `variants` - Map of variant names to optional variant types
    /// * `derive_traits` - Optional list of traits to derive
    ///
    /// # Returns
    /// Generated enum definition as a string
    pub fn generate_enum(
        &self,
        enum_name: &str,
        variants: HashMap<String, Option<String>>,
        derive_traits: Option<Vec<&str>>,
    ) -> String {
        let mut enum_def = String::new();

        // Add derive attributes if provided
        if let Some(traits) = derive_traits {
            if !traits.is_empty() {
                enum_def.push_str(&format!("#[derive({})]\n", traits.join(", ")));
            }
        }

        enum_def.push_str(&format!("pub enum {} {{\n", enum_name));

        // Add variants
        for (variant_name, variant_type) in variants {
            if let Some(type_str) = variant_type {
                enum_def.push_str(&format!("    {}({}),\n", variant_name, type_str));
            } else {
                enum_def.push_str(&format!("    {},\n", variant_name));
            }
        }

        enum_def.push_str("}\n");
        enum_def
    }

    /// Generates a function definition
    ///
    /// # Parameters
    /// * `fn_name` - Name of the function
    /// * `params` - Map of parameter names to parameter types
    /// * `return_type` - Optional return type
    /// * `body` - Function body
    ///
    /// # Returns
    /// Generated function definition as a string
    pub fn generate_function(
        &self,
        fn_name: &str,
        params: HashMap<String, String>,
        return_type: Option<&str>,
        body: &str,
    ) -> String {
        let mut param_str = String::new();
        for (param_name, param_type) in params {
            if !param_str.is_empty() {
                param_str.push_str(", ");
            }
            param_str.push_str(&format!("{}: {}", param_name, param_type));
        }

        let return_type_str = if let Some(rt) = return_type {
            format!(" -> {}", rt)
        } else {
            String::new()
        };

        format!(
            "fn {}({}){} {{\n    {}\n}}\n",
            fn_name, param_str, return_type_str, body
        )
    }

    /// Generates a method call
    ///
    /// # Parameters
    /// * `object` - Object to call the method on
    /// * `method_name` - Name of the method to call
    /// * `args` - Arguments to pass to the method
    ///
    /// # Returns
    /// Generated method call as a string
    pub fn generate_method_call(&self, object: &str, method_name: &str, args: &[&str]) -> String {
        let args_str = args.join(", ");
        format!("{}.{}({})", object, method_name, args_str)
    }
}

/// Registry for fix templates
#[derive(Debug, Default)]
pub struct TemplateRegistry {
    /// Map of template names to templates
    templates: HashMap<String, FixTemplate>,
}

impl TemplateRegistry {
    /// Creates a new TemplateRegistry
    pub fn new() -> Self {
        Self {
            templates: HashMap::new(),
        }
    }

    /// Registers a template
    ///
    /// # Parameters
    /// * `template` - Template to register
    pub fn register_template(&mut self, template: FixTemplate) {
        self.templates.insert(template.name.clone(), template);
    }

    /// Gets a template by name
    ///
    /// # Parameters
    /// * `name` - Name of the template to get
    ///
    /// # Returns
    /// The template with the given name, or None if not found
    pub fn get_template(&self, name: &str) -> Option<&FixTemplate> {
        self.templates.get(name)
    }

    /// Gets all templates that apply to a given error category
    ///
    /// # Parameters
    /// * `category` - Error category to filter by
    ///
    /// # Returns
    /// Vector of templates that apply to the given category
    pub fn get_templates_for_category(&self, category: ErrorCategory) -> Vec<&FixTemplate> {
        self.templates
            .values()
            .filter(|t| t.applicable_categories.contains(&category))
            .collect()
    }

    /// Gets all templates that target a given error code
    ///
    /// # Parameters
    /// * `error_code` - Error code to filter by
    ///
    /// # Returns
    /// Vector of templates that target the given error code
    pub fn get_templates_for_error_code(&self, error_code: &str) -> Vec<&FixTemplate> {
        self.templates
            .values()
            .filter(|t| t.target_error_codes.iter().any(|c| c == error_code))
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;

    #[test]
    fn test_fix_template_creation_and_application() {
        // Create a template with placeholders
        let template = FixTemplate::new(
            "test_template",
            "A test template for fixing errors",
            "fn {function_name}({param_name}: {param_type}) -> {return_type} {\n    // Implementation\n    {body}\n}"
        )
        .add_category(ErrorCategory::Validation)
        .add_error_code("E0001");

        // Verify template properties
        assert_eq!(template.name, "test_template");
        assert_eq!(template.description, "A test template for fixing errors");
        assert_eq!(template.applicable_categories.len(), 1);
        assert_eq!(template.applicable_categories[0], ErrorCategory::Validation);
        assert_eq!(template.target_error_codes.len(), 1);
        assert_eq!(template.target_error_codes[0], "E0001");

        // Create parameters to apply to the template
        let mut params = HashMap::new();
        params.insert("function_name".to_string(), "process_data".to_string());
        params.insert("param_name".to_string(), "data".to_string());
        params.insert("param_type".to_string(), "String".to_string());
        params.insert("return_type".to_string(), "Result<(), Error>".to_string());
        params.insert("body".to_string(), "Ok(())".to_string());

        // Apply the template with parameters
        let result = template.apply(&params);

        // Verify the result
        let expected = "fn process_data(data: String) -> Result<(), Error> {\n    // Implementation\n    Ok(())\n}";
        assert_eq!(result, expected);
    }

    #[test]
    fn test_syntax_generator_code_generation() {
        let generator = SyntaxGenerator::new();

        // Test generating an import statement
        let import_single = generator.generate_import("std::collections", &["HashMap"]);
        assert_eq!(import_single, "use std::collections::HashMap;");

        let import_multiple =
            generator.generate_import("std::collections", &["HashMap", "HashSet", "BTreeMap"]);
        assert_eq!(
            import_multiple,
            "use std::collections::{HashMap, HashSet, BTreeMap};"
        );

        let import_empty = generator.generate_import("std::collections", &[]);
        assert_eq!(import_empty, "use std::collections;");

        // Test generating a struct definition
        let mut fields = HashMap::new();
        fields.insert("name".to_string(), "String".to_string());
        fields.insert("age".to_string(), "u32".to_string());
        fields.insert("active".to_string(), "bool".to_string());

        let struct_def = generator.generate_struct("User", fields, Some(vec!["Debug", "Clone"]));

        // Verify struct definition contains expected elements
        assert!(struct_def.contains("#[derive(Debug, Clone)]"));
        assert!(struct_def.contains("pub struct User {"));
        assert!(struct_def.contains("pub name: String,"));
        assert!(struct_def.contains("pub age: u32,"));
        assert!(struct_def.contains("pub active: bool,"));
    }

    #[test]
    fn test_template_registry_operations() {
        let mut registry = TemplateRegistry::new();

        // Create templates
        let template1 = FixTemplate::new(
            "validation_fix",
            "Fix for validation errors",
            "// Validation fix for {field_name}",
        )
        .add_category(ErrorCategory::Validation)
        .add_error_code("E0001");

        let template2 = FixTemplate::new("io_fix", "Fix for IO errors", "// IO fix for {path}")
            .add_category(ErrorCategory::Io)
            .add_error_code("E0002");

        // Register templates
        registry.register_template(template1);
        registry.register_template(template2);

        // Test getting a template by name
        let validation_template = registry.get_template("validation_fix");
        assert!(validation_template.is_some());
        assert_eq!(
            validation_template.unwrap().description,
            "Fix for validation errors"
        );

        // Test getting templates for a category
        let io_templates = registry.get_templates_for_category(ErrorCategory::Io);
        assert_eq!(io_templates.len(), 1);
        assert_eq!(io_templates[0].name, "io_fix");

        // Test getting templates for an error code
        let e0001_templates = registry.get_templates_for_error_code("E0001");
        assert_eq!(e0001_templates.len(), 1);
        assert_eq!(e0001_templates[0].name, "validation_fix");
    }

    #[test]
    fn test_syntax_integration() {
        // Create a template registry
        let mut registry = TemplateRegistry::new();

        // Create a syntax generator
        let generator = SyntaxGenerator::new();

        // Generate a struct definition
        let mut fields = HashMap::new();
        fields.insert("id".to_string(), "u64".to_string());
        fields.insert("name".to_string(), "String".to_string());

        let struct_def = generator.generate_struct("User", fields, Some(vec!["Debug", "Clone"]));

        // Create a template using the struct definition
        let template = FixTemplate::new(
            "user_struct_template",
            "Template for User struct",
            struct_def,
        )
        .add_category(ErrorCategory::Validation);

        // Register the template
        registry.register_template(template);

        // Retrieve the template
        let retrieved_template = registry.get_template("user_struct_template").unwrap();

        // Verify the template contains the struct definition
        assert!(retrieved_template.template.contains("pub struct User {"));
        assert!(retrieved_template.template.contains("pub id: u64,"));
        assert!(retrieved_template.template.contains("pub name: String,"));
    }
}

File: types.rs
==============
/* src/common/error/types.rs */
#![warn(missing_docs)]
//! **Brief:** Core error-related structs and types for the error handling framework.
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
//! + [Error Handling Framework]
//!  - [Type Definitions]
//!  - [Error Context Structures]
//!  - [Diagnostic Utilities]
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
// **GitHub:** [ArcMoon Studios](https://github.com/arcmoonstudios)
// **Copyright:** (c) 2025 ArcMoon Studios
// **Author:** Lord Xyn
// **License:** MIT

use std::collections::HashMap;
use std::path::PathBuf;
use std::time::SystemTime;

// Note: Depending on feature flags you might use chrono::DateTime<Utc> instead of SystemTime
type TimestampType = SystemTime;

/// Severity level for errors
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum ErrorSeverity {
    /// Debug level - lowest severity, for detailed debugging information
    Debug,
    /// Info level - general information, not errors
    Info,
    /// Warning level - potential issues that don't prevent operation
    Warning,
    /// Error level - issues that prevent a specific operation from completing
    Error,
    /// Critical level - severe issues that may affect system stability
    Critical,
}

/// Categorization of errors
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum ErrorCategory {
    /// Input/Output related errors (file system, streams, etc.)
    Io,
    /// Errors related to parsing data formats (JSON, YAML, etc.)
    Parsing,
    /// Network communication errors
    Network,
    /// Configuration-related errors (missing or invalid config)
    Configuration,
    /// Data validation errors
    Validation,
    /// Internal system errors
    Internal,
    /// Circuit breaker pattern related errors
    CircuitBreaker,
    /// Operation timeout errors
    Timeout,
    /// Resource exhaustion errors (memory, connections, etc.)
    ResourceExhaustion,
    /// Resource not found errors
    NotFound,
    /// Concurrency-related errors (race conditions, deadlocks)
    Concurrency,
    /// External service integration errors
    ExternalService,
    /// Authentication failures
    Authentication,
    /// Authorization/permission errors
    Authorization,
    /// State conflict errors (e.g., optimistic concurrency failures)
    StateConflict,
    /// Multiple errors grouped together
    Multiple,
    /// Code style and formatting issues
    Style,
    /// Runtime behavior errors (panics, unwraps, etc.)
    Runtime,
    /// Unspecified or unknown error category
    Unspecified,
}

impl std::fmt::Display for ErrorCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Io => write!(f, "IO"),
            Self::Parsing => write!(f, "Parsing"),
            Self::Network => write!(f, "Network"),
            Self::Configuration => write!(f, "Configuration"),
            Self::Validation => write!(f, "Validation"),
            Self::Internal => write!(f, "Internal"),
            Self::CircuitBreaker => write!(f, "Circuit Breaker"),
            Self::Timeout => write!(f, "Timeout"),
            Self::ResourceExhaustion => write!(f, "Resource Exhaustion"),
            Self::NotFound => write!(f, "Not Found"),
            Self::Concurrency => write!(f, "Concurrency"),
            Self::ExternalService => write!(f, "External Service"),
            Self::Authentication => write!(f, "Authentication"),
            Self::Authorization => write!(f, "Authorization"),
            Self::StateConflict => write!(f, "State Conflict"),
            Self::Multiple => write!(f, "Multiple Errors"),
            Self::Style => write!(f, "Style"),
            Self::Runtime => write!(f, "Runtime"),
            Self::Unspecified => write!(f, "Unspecified"),
        }
    }
}

/// Output formats for error reports
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ErrorReportFormat {
    /// Plain text format
    Plain,
    /// JSON structured format
    Json,
    /// Markdown formatted text
    Markdown,
    /// HTML formatted output
    Html,
}

impl std::fmt::Display for ErrorReportFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Plain => write!(f, "Plain"),
            Self::Json => write!(f, "JSON"),
            Self::Markdown => write!(f, "Markdown"),
            Self::Html => write!(f, "HTML"),
        }
    }
}

/// Nature of a proposed autocorrection fix
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FixType {
    /// Simple text replacement in a file
    TextReplacement,
    /// Modification of the Abstract Syntax Tree (more complex than text replacement)
    AstModification,
    /// Add an import statement to a file
    AddImport,
    /// Add a dependency to a project
    AddDependency,
    /// Change configuration settings
    ConfigurationChange,
    /// Execute a command to fix the issue
    ExecuteCommand,
    /// Refactor code (more complex structural changes)
    Refactor,
    /// Issue requires manual intervention by the developer
    ManualInterventionRequired,
    /// Informational fix (provides information but no actual code change)
    Information,
    /// Update Cargo.toml file specifically
    UpdateCargoToml,
    /// Run a specific Cargo command
    RunCargoCommand,
    /// Suggest an alternative method or approach
    SuggestAlternativeMethod,
}

impl std::fmt::Display for FixType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::TextReplacement => write!(f, "Text Replacement"),
            Self::AstModification => write!(f, "AST Modification"),
            Self::AddImport => write!(f, "Add Import"),
            Self::AddDependency => write!(f, "Add Dependency"),
            Self::ConfigurationChange => write!(f, "Configuration Change"),
            Self::ExecuteCommand => write!(f, "Command Execution"),
            Self::Refactor => write!(f, "Code Refactoring"),
            Self::ManualInterventionRequired => write!(f, "Manual Intervention Required"),
            Self::Information => write!(f, "Information"),
            Self::UpdateCargoToml => write!(f, "Update Cargo.toml"),
            Self::RunCargoCommand => write!(f, "Run Cargo Command"),
            Self::SuggestAlternativeMethod => write!(f, "Suggest Alternative Method"),
        }
    }
}

/// Detailed information for specific fix types
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum FixDetails {
    /// Replace text in a file with new content
    TextReplace {
        /// Path to the file to modify
        file_path: PathBuf,
        /// Starting line number (1-based)
        line_start: usize,
        /// Starting column number (1-based)
        column_start: usize,
        /// Ending line number (1-based)
        line_end: usize,
        /// Ending column number (1-based)
        column_end: usize,
        /// Original text that will be replaced (for verification)
        original_text_snippet: Option<String>,
        /// New text to insert
        replacement_text: String,
    },
    /// Add an import statement to a file
    AddImport {
        /// Path to the file where the import should be added
        file_path: String,
        /// The import statement to add
        import: String,
    },
    /// Add a dependency to Cargo.toml
    AddCargoDependency {
        /// Name of the dependency
        dependency: String,
        /// Version constraint for the dependency
        version: String,
        /// Optional features to enable
        features: Vec<String>,
        /// Whether this is a dev-dependency
        is_dev_dependency: bool,
    },
    /// Execute a command to fix the issue
    ExecuteCommand {
        /// The command to execute
        command: String,
        /// Arguments to pass to the command
        args: Vec<String>,
        /// Working directory for the command
        working_directory: Option<PathBuf>,
    },
    /// Suggest a command to run to fix the issue
    SuggestCommand {
        /// The command to suggest
        command: String,
        /// Explanation of what the command does
        explanation: String,
    },
    /// Suggest a code change without applying it
    SuggestCodeChange {
        /// Path to the file that needs changes
        file_path: PathBuf,
        /// Line number hint for where the change should be made
        line_hint: usize,
        /// The suggested code snippet
        suggested_code_snippet: String,
        /// Explanation of why this change is suggested
        explanation: String,
    },
}

/// Describes the source location of an error
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ErrorSource {
    /// Path to the file where the error occurred
    pub file: String,
    /// Line number in the file where the error occurred
    pub line: u32,
    /// Module path (e.g., "crate::module::submodule")
    pub module_path: String,
    /// Optional column number for more precise location
    pub column: Option<u32>,
    /// Optional function name where the error occurred
    pub function: Option<String>,
}

impl ErrorSource {
    /// Creates a new ErrorSource with the given file, line, and module path
    ///
    /// # Parameters
    /// * `file` - Path to the file where the error occurred
    /// * `line` - Line number in the file where the error occurred
    /// * `module_path` - Module path (e.g., "crate::module::submodule")
    pub fn new(file: impl Into<String>, line: u32, module_path: impl Into<String>) -> Self {
        Self {
            file: file.into(),
            line,
            module_path: module_path.into(),
            column: None,
            function: None,
        }
    }

    /// Adds a column number to the error source location
    ///
    /// # Parameters
    /// * `column` - Column number for more precise location
    pub fn with_column(mut self, column: u32) -> Self {
        self.column = Some(column);
        self
    }

    /// Adds a function name to the error source location
    ///
    /// # Parameters
    /// * `function` - Function name where the error occurred
    pub fn with_function(mut self, function: impl Into<String>) -> Self {
        self.function = Some(function.into());
        self
    }
}

/// Specific location for diagnostic purposes
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ErrorLocation {
    /// Path to the file where the error occurred
    pub file: String,
    /// Line number in the file where the error occurred
    pub line: u32,
    /// Column number in the file where the error occurred
    pub column: u32,
    /// Function or context string describing where the error occurred
    pub function_context: String,
    /// Optional Snafu error variant name if this location is from a Snafu error
    pub decrust_variant: Option<String>,
}

impl ErrorLocation {
    /// Creates a new ErrorLocation with the given file, line, column, and function context
    ///
    /// # Parameters
    /// * `file` - Path to the file where the error occurred
    /// * `line` - Line number in the file where the error occurred
    /// * `column` - Column number in the file where the error occurred
    /// * `function_context` - Function or context string describing where the error occurred
    pub fn new(
        file: impl Into<String>,
        line: u32,
        column: u32,
        function_context: impl Into<String>,
    ) -> Self {
        Self {
            file: file.into(),
            line,
            column,
            function_context: function_context.into(),
            decrust_variant: None,
        }
    }

    /// Adds a Snafu error variant name to the error location
    ///
    /// # Parameters
    /// * `variant` - Snafu error variant name
    pub fn with_snafu_variant(mut self, variant: impl Into<String>) -> Self {
        self.decrust_variant = Some(variant.into());
        self
    }
}

/// A step in a macro expansion trace
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct MacroExpansion {
    /// Name of the macro that was expanded
    pub macro_name: String,
    /// Location where the macro was expanded
    pub expansion_site: ErrorLocation,
    /// Code snippet generated by the macro expansion
    pub generated_code_snippet: String,
}

/// Holds detailed diagnostic information
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct DiagnosticResult {
    /// Primary location where the error occurred
    pub primary_location: Option<ErrorLocation>,
    /// Trace of macro expansions if the error occurred in a macro
    pub expansion_trace: Vec<MacroExpansion>,
    /// List of suggested fixes for the error
    pub suggested_fixes: Vec<String>,
    /// Original error message from the diagnostic tool
    pub original_message: Option<String>,
    /// Diagnostic code (e.g., "E0001") from the diagnostic tool
    pub diagnostic_code: Option<String>,
}

/// Additional structured context for an error
#[derive(Debug, Clone)]
pub struct ErrorContext {
    /// Main error message
    pub message: String,
    /// Source location information for the error
    pub source_location: Option<ErrorSource>,
    /// Optional suggestion for how to recover from the error
    pub recovery_suggestion: Option<String>,
    /// Additional key-value metadata associated with the error
    pub metadata: HashMap<String, String>,
    /// Severity level of the error
    pub severity: ErrorSeverity,
    /// Timestamp when the error occurred
    pub timestamp: Option<TimestampType>,
    /// Correlation ID for tracking related errors across systems
    pub correlation_id: Option<String>,
    /// Component or subsystem where the error occurred
    pub component: Option<String>,
    /// Tags for categorizing or filtering errors
    pub tags: Vec<String>,
    /// Detailed diagnostic information if available
    pub diagnostic_info: Option<DiagnosticResult>,
}

impl ErrorContext {
    /// Creates a new ErrorContext with the given message
    ///
    /// # Parameters
    /// * `message` - Main error message
    pub fn new(message: impl Into<String>) -> Self {
        Self {
            message: message.into(),
            source_location: None,
            recovery_suggestion: None,
            metadata: HashMap::new(),
            severity: ErrorSeverity::Error,
            timestamp: Some(SystemTime::now()),
            correlation_id: None,
            component: None,
            tags: Vec::new(),
            diagnostic_info: None,
        }
    }

    /// Sets the severity level of the error
    ///
    /// # Parameters
    /// * `severity` - Severity level to set
    pub fn with_severity(mut self, severity: ErrorSeverity) -> Self {
        self.severity = severity;
        self
    }

    /// Adds source location information to the error context
    ///
    /// # Parameters
    /// * `source_location` - Source location information
    pub fn with_source_location(mut self, source_location: ErrorSource) -> Self {
        self.source_location = Some(source_location);
        self
    }

    /// Adds a recovery suggestion to the error context
    ///
    /// # Parameters
    /// * `suggestion` - Suggestion for how to recover from the error
    pub fn with_recovery_suggestion(mut self, suggestion: impl Into<String>) -> Self {
        self.recovery_suggestion = Some(suggestion.into());
        self
    }

    /// Adds a metadata key-value pair to the error context
    ///
    /// # Parameters
    /// * `key` - Metadata key
    /// * `value` - Metadata value
    pub fn with_metadata(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.metadata.insert(key.into(), value.into());
        self
    }

    /// Adds a correlation ID to the error context
    ///
    /// # Parameters
    /// * `id` - Correlation ID for tracking related errors
    pub fn with_correlation_id(mut self, id: impl Into<String>) -> Self {
        self.correlation_id = Some(id.into());
        self
    }

    /// Adds a component name to the error context
    ///
    /// # Parameters
    /// * `component` - Component or subsystem where the error occurred
    pub fn with_component(mut self, component: impl Into<String>) -> Self {
        self.component = Some(component.into());
        self
    }

    /// Adds a tag to the error context
    ///
    /// # Parameters
    /// * `tag` - Tag for categorizing or filtering errors
    pub fn add_tag(mut self, tag: impl Into<String>) -> Self {
        self.tags.push(tag.into());
        self
    }

    /// Adds detailed diagnostic information to the error context
    ///
    /// # Parameters
    /// * `diagnostic` - Detailed diagnostic information
    pub fn with_diagnostic_info(mut self, diagnostic: DiagnosticResult) -> Self {
        self.diagnostic_info = Some(diagnostic);
        self
    }
}

/// A proposed autocorrection for an error
#[derive(Debug, Clone)]
pub struct Autocorrection {
    /// Human-readable description of the autocorrection
    pub description: String,
    /// Type of fix being proposed
    pub fix_type: FixType,
    /// Confidence level (0.0 to 1.0) in the correctness of this fix
    pub confidence: f64,
    /// Detailed information about the fix
    pub details: Option<FixDetails>,
    /// Optional diff-style representation of the suggested change
    pub diff_suggestion: Option<String>,
    /// Shell commands that can be executed to apply the fix
    pub commands_to_apply: Vec<String>,
    /// Error code that this autocorrection targets
    pub targets_error_code: Option<String>,
}

impl Autocorrection {
    /// Creates a new Autocorrection with the given description, fix type, and confidence level
    ///
    /// # Parameters
    /// * `description` - Human-readable description of the autocorrection
    /// * `fix_type` - Type of fix being proposed
    /// * `confidence` - Confidence level (0.0 to 1.0) in the correctness of this fix
    pub fn new(description: impl Into<String>, fix_type: FixType, confidence: f64) -> Self {
        Self {
            description: description.into(),
            fix_type,
            confidence,
            details: None,
            diff_suggestion: None,
            commands_to_apply: Vec::new(),
            targets_error_code: None,
        }
    }

    /// Adds detailed information about the fix
    ///
    /// # Parameters
    /// * `details` - Detailed information about how to apply the fix
    pub fn with_details(mut self, details: FixDetails) -> Self {
        self.details = Some(details);
        self
    }

    /// Adds a diff-style representation of the suggested change
    ///
    /// # Parameters
    /// * `diff` - Diff-style representation of the change
    pub fn with_diff_suggestion(mut self, diff: impl Into<String>) -> Self {
        self.diff_suggestion = Some(diff.into());
        self
    }

    /// Adds a shell command that can be executed to apply the fix
    ///
    /// # Parameters
    /// * `command` - Shell command to execute
    pub fn add_command(mut self, command: impl Into<String>) -> Self {
        self.commands_to_apply.push(command.into());
        self
    }

    /// Sets the error code that this autocorrection targets
    ///
    /// # Parameters
    /// * `code` - Error code (e.g., "E0001")
    pub fn with_target_error_code(mut self, code: impl Into<String>) -> Self {
        self.targets_error_code = Some(code.into());
        self
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_error_severity_ordering() {
        assert!(ErrorSeverity::Critical > ErrorSeverity::Error);
        assert!(ErrorSeverity::Error > ErrorSeverity::Warning);
        assert!(ErrorSeverity::Warning > ErrorSeverity::Info);
        assert!(ErrorSeverity::Info > ErrorSeverity::Debug);
    }

    #[test]
    fn test_error_context_building() {
        let context = ErrorContext::new("Test error")
            .with_severity(ErrorSeverity::Warning)
            .with_recovery_suggestion("Try again")
            .with_metadata("request_id", "123456")
            .with_correlation_id("corr-789")
            .with_component("auth_service")
            .add_tag("security");

        assert_eq!(context.message, "Test error");
        assert_eq!(context.severity, ErrorSeverity::Warning);
        assert_eq!(context.recovery_suggestion, Some("Try again".to_string()));
        assert_eq!(
            context.metadata.get("request_id"),
            Some(&"123456".to_string())
        );
        assert_eq!(context.correlation_id, Some("corr-789".to_string()));
        assert_eq!(context.component, Some("auth_service".to_string()));
        assert_eq!(context.tags.len(), 1);
        assert_eq!(context.tags[0], "security");
    }

    #[test]
    fn test_error_source() {
        let source = ErrorSource::new("src/main.rs", 42, "main")
            .with_column(10)
            .with_function("process_data");

        assert_eq!(source.file, "src/main.rs");
        assert_eq!(source.line, 42);
        assert_eq!(source.module_path, "main");
        assert_eq!(source.column, Some(10));
        assert_eq!(source.function, Some("process_data".to_string()));
    }

    #[test]
    fn test_fix_details_variants() {
        // Test TextReplace variant
        let text_replace = FixDetails::TextReplace {
            file_path: PathBuf::from("src/main.rs"),
            line_start: 10,
            column_start: 5,
            line_end: 10,
            column_end: 15,
            original_text_snippet: Some("foo(bar)".to_string()),
            replacement_text: "foo(baz)".to_string(),
        };

        // Test ExecuteCommand variant
        let exec_command = FixDetails::ExecuteCommand {
            command: "cargo".to_string(),
            args: vec!["fix".to_string(), "--allow-dirty".to_string()],
            working_directory: Some(PathBuf::from(".")),
        };

        // Test SuggestCodeChange variant
        let suggest_code = FixDetails::SuggestCodeChange {
            file_path: PathBuf::from("src/lib.rs"),
            line_hint: 42,
            suggested_code_snippet: "impl Clone for MyStruct {}".to_string(),
            explanation: "Add Clone implementation".to_string(),
        };

        // Verify they're different variants
        assert!(matches!(text_replace, FixDetails::TextReplace { .. }));
        assert!(matches!(exec_command, FixDetails::ExecuteCommand { .. }));
        assert!(matches!(suggest_code, FixDetails::SuggestCodeChange { .. }));
    }

    #[test]
    fn test_autocorrection_building() {
        let autocorrection = Autocorrection::new("Fix parse error", FixType::TextReplacement, 0.85)
            .with_details(FixDetails::TextReplace {
                file_path: PathBuf::from("src/main.rs"),
                line_start: 10,
                column_start: 5,
                line_end: 10,
                column_end: 15,
                original_text_snippet: Some("foo(bar)".to_string()),
                replacement_text: "foo(baz)".to_string(),
            })
            .with_diff_suggestion("@@ -10,5 +10,5 @@\n-foo(bar)\n+foo(baz)")
            .add_command("cargo check")
            .with_target_error_code("E0001");

        assert_eq!(autocorrection.description, "Fix parse error");
        assert_eq!(autocorrection.fix_type, FixType::TextReplacement);
        assert_eq!(autocorrection.confidence, 0.85);
        assert!(autocorrection.details.is_some());
        assert_eq!(
            autocorrection.diff_suggestion,
            Some("@@ -10,5 +10,5 @@\n-foo(bar)\n+foo(baz)".to_string())
        );
        assert_eq!(autocorrection.commands_to_apply.len(), 1);
        assert_eq!(autocorrection.commands_to_apply[0], "cargo check");
        assert_eq!(autocorrection.targets_error_code, Some("E0001".to_string()));
    }

    #[test]
    fn test_error_category_display_and_debug() {
        // Test Display implementation for ErrorCategory
        assert_eq!(format!("{}", ErrorCategory::Io), "IO");
        assert_eq!(format!("{}", ErrorCategory::Parsing), "Parsing");
        assert_eq!(format!("{}", ErrorCategory::Network), "Network");
        assert_eq!(format!("{}", ErrorCategory::Configuration), "Configuration");
        assert_eq!(format!("{}", ErrorCategory::Validation), "Validation");
        assert_eq!(format!("{}", ErrorCategory::Internal), "Internal");

        // Test Debug implementation for ErrorCategory
        assert_eq!(format!("{:?}", ErrorCategory::Io), "Io");
        assert_eq!(format!("{:?}", ErrorCategory::Parsing), "Parsing");
        assert_eq!(format!("{:?}", ErrorCategory::Network), "Network");
        assert_eq!(
            format!("{:?}", ErrorCategory::Configuration),
            "Configuration"
        );
        assert_eq!(format!("{:?}", ErrorCategory::Validation), "Validation");
        assert_eq!(format!("{:?}", ErrorCategory::Internal), "Internal");
    }

    #[test]
    fn test_error_report_format_display_and_debug() {
        // Test Display implementation for ErrorReportFormat
        assert_eq!(format!("{}", ErrorReportFormat::Plain), "Plain");
        assert_eq!(format!("{}", ErrorReportFormat::Json), "JSON");
        assert_eq!(format!("{}", ErrorReportFormat::Markdown), "Markdown");
        assert_eq!(format!("{}", ErrorReportFormat::Html), "HTML");

        // Test Debug implementation for ErrorReportFormat
        assert_eq!(format!("{:?}", ErrorReportFormat::Plain), "Plain");
        assert_eq!(format!("{:?}", ErrorReportFormat::Json), "Json");
        assert_eq!(format!("{:?}", ErrorReportFormat::Markdown), "Markdown");
        assert_eq!(format!("{:?}", ErrorReportFormat::Html), "Html");
    }

    #[test]
    fn test_fix_type_display_and_debug() {
        // Test Display implementation for FixType
        assert_eq!(format!("{}", FixType::TextReplacement), "Text Replacement");
        assert_eq!(format!("{}", FixType::ExecuteCommand), "Command Execution");
        assert_eq!(
            format!("{}", FixType::ManualInterventionRequired),
            "Manual Intervention Required"
        );

        // Test Debug implementation for FixType
        assert_eq!(format!("{:?}", FixType::TextReplacement), "TextReplacement");
        assert_eq!(format!("{:?}", FixType::ExecuteCommand), "ExecuteCommand");
        assert_eq!(
            format!("{:?}", FixType::ManualInterventionRequired),
            "ManualInterventionRequired"
        );
    }
}

/// Source of extracted parameters
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ParameterSource {
    /// Extracted from error message
    ErrorMessage,
    /// Extracted from error context
    ErrorContext,
    /// Extracted from diagnostic information
    DiagnosticInfo,
    /// Extracted from backtrace
    Backtrace,
    /// Extracted from source code
    SourceCode,
    /// Manually specified
    Manual,
}

impl Default for ParameterSource {
    fn default() -> Self {
        Self::Manual
    }
}

/// Represents parameters extracted from error contexts
#[derive(Debug, Clone, Default)]
pub struct ExtractedParameters {
    /// Key-value pairs of extracted parameters
    pub values: HashMap<String, String>,
    /// Confidence level in the extracted parameters (0.0 to 1.0)
    pub confidence: f64,
    /// Source of the parameters (error message, backtrace, etc.)
    pub source: ParameterSource,
}

impl ExtractedParameters {
    /// Creates a new ExtractedParameters instance
    pub fn new() -> Self {
        Self {
            values: HashMap::new(),
            confidence: 0.0,
            source: ParameterSource::Manual,
        }
    }

    /// Creates a new ExtractedParameters instance with the given source and confidence
    pub fn with_source(source: ParameterSource, confidence: f64) -> Self {
        Self {
            values: HashMap::new(),
            confidence,
            source,
        }
    }

    /// Adds a parameter to the collection
    pub fn add_parameter(&mut self, key: impl Into<String>, value: impl Into<String>) -> &mut Self {
        self.values.insert(key.into(), value.into());
        self
    }

    /// Sets the confidence level
    pub fn set_confidence(&mut self, confidence: f64) -> &mut Self {
        self.confidence = confidence;
        self
    }

    /// Sets the source of the parameters
    pub fn set_source(&mut self, source: ParameterSource) -> &mut Self {
        self.source = source;
        self
    }

    /// Merges another ExtractedParameters instance into this one
    pub fn merge(&mut self, other: &ExtractedParameters) -> &mut Self {
        // Only merge if the other instance has a higher or equal confidence
        if other.confidence >= self.confidence {
            // For parameters that exist in both, keep the one from the higher confidence source
            for (key, value) in &other.values {
                if !self.values.contains_key(key) || other.confidence > self.confidence {
                    self.values.insert(key.clone(), value.clone());
                }
            }

            // If the other instance has higher confidence, update our confidence and source
            if other.confidence > self.confidence {
                self.confidence = other.confidence;
                self.source = other.source.clone();
            }
        }
        self
    }
}

/// A template for generating fixes
#[derive(Debug, Clone)]
pub struct FixTemplate {
    /// Template for the description
    pub description_template: String,
    /// Fix type to use
    pub fix_type: FixType,
    /// Base confidence level
    pub base_confidence: f64,
    /// Template for commands to apply
    pub command_templates: Vec<String>,
}

impl FixTemplate {
    /// Creates a new FixTemplate
    pub fn new(
        description_template: impl Into<String>,
        fix_type: FixType,
        base_confidence: f64,
    ) -> Self {
        Self {
            description_template: description_template.into(),
            fix_type,
            base_confidence,
            command_templates: Vec::new(),
        }
    }

    /// Adds a command template
    pub fn add_command_template(&mut self, template: impl Into<String>) -> &mut Self {
        self.command_templates.push(template.into());
        self
    }

    /// Applies parameters to this template to create an Autocorrection
    pub fn apply(&self, params: &ExtractedParameters) -> Autocorrection {
        let description = self.apply_template(&self.description_template, params);

        let commands = self
            .command_templates
            .iter()
            .map(|template| self.apply_template(template, params))
            .collect();

        Autocorrection {
            description,
            fix_type: self.fix_type,
            confidence: self.base_confidence * params.confidence,
            details: None,
            diff_suggestion: None,
            commands_to_apply: commands,
            targets_error_code: None,
        }
    }

    /// Applies parameters to a template string
    fn apply_template(&self, template: &str, params: &ExtractedParameters) -> String {
        let mut result = template.to_string();

        for (key, value) in &params.values {
            result = result.replace(&format!("{{{}}}", key), value);
        }

        result
    }
}

/// Trait for extracting parameters from errors
pub trait ParameterExtractor {
    /// Extracts parameters from an error
    fn extract_parameters(&self, error: &super::DecrustError) -> ExtractedParameters;

    /// Returns the name of this extractor
    fn name(&self) -> &'static str;

    /// Returns the error categories this extractor supports
    fn supported_categories(&self) -> &[ErrorCategory];
}

/// Trait for generating fixes based on errors and parameters
pub trait FixGenerator {
    /// Generates a fix for an error using extracted parameters
    fn generate_fix(
        &self,
        error: &super::DecrustError,
        params: &ExtractedParameters,
        source_code_context: Option<&str>,
    ) -> Option<Autocorrection>;

    /// Returns the name of this generator
    fn name(&self) -> &'static str;
}


